[
  {
    "input": "The collaborative robot can guarantee that it will keep running the cycle until a stop is requested.",
    "gold": "<<Cobot>>(cycle_running U stop_requested)",
    "prediction": "<<robot>>G(!stop_requested -> running_cycle)",
    "correct": "no",
    "reasoning": "Gold is an until property: cycle_running must hold up to the point when stop_requested occurs, and stop_requested is required to eventually occur. Prediction is a global implication that only enforces running_cycle while stop_requested is false, but does not require stop_requested to ever happen, so it is weaker and not equivalent.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The robotic arm can guarantee that if the object is fragile, then it will never exceed a maximum force.",
    "gold": "<<Arm>>G (fragile_object -> G !force_over_limit)",
    "prediction": "<<RoboticArm>>G(fragile -> G(!exceedMaxForce))",
    "correct": "yes",
    "reasoning": "Same coalition (Arm/RoboticArm) and same temporal structure: globally, if the object is fragile then globally the force limit is not exceeded. Predicate names are clear paraphrases (fragile_object≈fragile, force_over_limit≈exceedMaxForce).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The agricultural system can guarantee that if the soil is dry, then at the next step it will enable irrigation.",
    "gold": "<<AgriSystem>>G (soil_dry -> X irrigation_on)",
    "prediction": "<<agricultural_system>>G(soil_dry -> X enable_irrigation)",
    "correct": "yes",
    "reasoning": "Same coalition (agricultural system) and same temporal structure G(-> X). Predicate names are consistent aliases: irrigation_on vs enable_irrigation both denote enabling irrigation.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The drone can guarantee that it will keep holding altitude until it receives a descend command.",
    "gold": "<<Drone>>(holding_altitude U descend_command)",
    "prediction": "<<drone>>(hold_altitude U descend_command)",
    "correct": "yes",
    "reasoning": "Same coalition (Drone) and same until structure; predicate names are clear aliases (holding_altitude vs hold_altitude) with identical polarity and temporal operator.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The security system can guarantee that it will keep monitoring until the threat is removed.",
    "gold": "<<SecuritySystem>>(monitoring U threat_removed)",
    "prediction": "<<security_system>>(monitoring U !threat)",
    "correct": "no",
    "reasoning": "Gold requires monitoring to hold until the proposition threat_removed becomes true. The prediction instead uses (monitoring U !threat), which is not equivalent: it changes the terminating condition from an explicit removal event to a state where threat is false, and also changes the atomic proposition (threat_removed vs !threat).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The logistics system can guarantee that sooner or later the delivery will be completed.",
    "gold": "<<LogisticsSystem>>F delivery_done",
    "prediction": "<<logistics_system>>F(delivery_completed)",
    "correct": "yes",
    "reasoning": "Same coalition (logistics system) and same temporal operator F expressing eventual completion; predicate name is an obvious alias of delivery_done.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The smart city system can guarantee that if an intersection is congested, then at the next step it will retime the traffic lights.",
    "gold": "<<CitySystem>>G (junction_congested -> X lights_retimed)",
    "prediction": "<<smart_city_system>>G(congested -> X(retime_traffic_lights))",
    "correct": "yes",
    "reasoning": "Same coalition (smart city system/CitySystem) and same temporal structure: globally, if congestion holds then in the next step lights are retimed. Predicate names are clear paraphrases (junction_congested≈congested, lights_retimed≈retime_traffic_lights).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if the safety barrier is on, then it will always remain stopped.",
    "gold": "<<Cobot>>G (safety_barrier_on -> G stopped)",
    "prediction": "<<collaborative_robot>>G(safety_barrier_on -> G(stopped))",
    "correct": "yes",
    "reasoning": "Same coalition (collaborative robot/Cobot) and same temporal structure: globally, if safety_barrier_on holds then globally stopped holds. Parentheses/casing differences do not change semantics.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system can guarantee that if an intruder is detected, then at the next step it will send an alarm.",
    "gold": "<<System>>G (intruder_detected -> X alarm_sent)",
    "prediction": "<<system>>G(detected -> X alarm)",
    "correct": "no",
    "reasoning": "Although the temporal structure G( -> X ) matches, the atomic propositions are not preserved: 'intruder_detected' was changed to 'detected' and 'alarm_sent' to 'alarm', which are not clear aliases and could change the meaning (e.g., detected could refer to something else; alarm could mean alarm condition rather than sending it). Coalition case difference is irrelevant, but predicate changes make it semantically incorrect.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if a stop is requested, then at the next step it will stop moving.",
    "gold": "<<Cobot>>G (stop_requested -> X stopped)",
    "prediction": "<<collaborative_robot>>G(stop_requested -> X(stopped_moving))",
    "correct": "yes",
    "reasoning": "Same coalition (collaborative robot/Cobot) and same temporal structure G(stop_requested -> X ...). Predicate 'stopped_moving' matches the described 'stop moving' and is consistent with 'stopped' in the gold.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The robotic arm can guarantee that if the gripper is closed, then sooner or later the object will be lifted.",
    "gold": "<<Arm>>G (gripper_closed -> F object_lifted)",
    "prediction": "<<RoboticArm>>G(closed -> F(lifted))",
    "correct": "yes",
    "reasoning": "Same coalition (Arm vs RoboticArm) and same temporal structure: globally, if gripper is closed then eventually the object is lifted. Predicate names are clear aliases (gripper_closed/closed, object_lifted/lifted).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The Mars rover can guarantee that sooner or later it will reach the sampling site.",
    "gold": "<<Rover>>F at_sampling_site",
    "prediction": "<<MarsRover>>F(reach_sampling_site)",
    "correct": "yes",
    "reasoning": "Same coalition (Mars rover/Rover) and same eventuality operator F. Predicate names are consistent aliases for reaching/being at the sampling site.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system can guarantee that it will keep monitoring until the observation window ends.",
    "gold": "<<System>>(monitoring U window_closed)",
    "prediction": "<<system>>(monitoring U observation_window_ends)",
    "correct": "yes",
    "reasoning": "Same coalition (System) and same until structure. The predicate 'observation_window_ends' is a clear alias of 'window_closed' from the sentence, so the meaning is preserved.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The machine can guarantee that the system remains safe until cancellation is requested.",
    "gold": "<<Machine>>(safe U cancel)",
    "prediction": "<<machine>> (safe U cancellation_requested)",
    "correct": "yes",
    "reasoning": "Coalition is the machine (case difference only) and the formula uses the same until structure: safe holds until a cancellation is requested. Predicate names cancel vs cancellation_requested are clear aliases.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The industrial system can guarantee that sooner or later production will be completed.",
    "gold": "<<IndustrySystem>>F production_done",
    "prediction": "<<industrial_system>>F production_completed",
    "correct": "yes",
    "reasoning": "Same coalition (industrial system) and same temporal operator F expressing eventual completion; predicate names are clear aliases for production being completed.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system and the teacher together can guarantee that sooner or later the student will be certified.",
    "gold": "<<EduSystem,Teacher>>F certified",
    "prediction": "<<system,teacher>>F certified",
    "correct": "yes",
    "reasoning": "Same coalition (system and teacher) and same temporal operator F ensuring eventual certification; only capitalization differs.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The industrial system can guarantee that if a machine overheats, then at the next step it will shut down.",
    "gold": "<<IndustrySystem>>G (overheating -> X shutdown)",
    "prediction": "<<industrial_system>>G(overheats -> X(shut_down))",
    "correct": "yes",
    "reasoning": "Same coalition (industrial system) and same temporal structure: globally, if overheating occurs then in the next step shutdown holds. Predicate names are clear aliases (overheating/overheats, shutdown/shut_down).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if a human enters the area, then at the next step it will reduce speed.",
    "gold": "<<Cobot>>G (human_in_area -> X speed_low)",
    "prediction": "<<robot>>G((human_enters_area -> X(reduce_speed)))",
    "correct": "yes",
    "reasoning": "Same coalition (collaborative robot) and same temporal structure: globally, if a human enters/is in the area then in the next step speed is reduced. Predicate names are consistent paraphrases (human_in_area vs human_enters_area; speed_low vs reduce_speed).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The surveillance system can guarantee that sooner or later it will archive the logs after the shift ends.",
    "gold": "<<System>>F logs_archived",
    "prediction": "<<SurveillanceSystem>>F(shift_ends & F archive_logs)",
    "correct": "no",
    "reasoning": "Gold only requires the system can eventually ensure logs are archived (<<System>>F logs_archived) with no condition about the shift ending. The prediction adds an extra constraint: shift_ends must occur and only then eventually archive_logs (F(shift_ends & F archive_logs)), which is stronger and not equivalent. Also the temporal nesting differs from a simple eventuality.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The surveillance system can guarantee that if an intruder enters the area, then sooner or later it will detect the intruder.",
    "gold": "<<System>>G (intruder_entered -> F intruder_detected)",
    "prediction": "<<surveillance_system>>G((intruder_enters) -> F(detect_intruder))",
    "correct": "yes",
    "reasoning": "Same coalition (surveillance system/system) and same temporal structure: globally, if an intruder enters then eventually the intruder is detected. Predicate names are clear paraphrases.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5.2_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  }
]