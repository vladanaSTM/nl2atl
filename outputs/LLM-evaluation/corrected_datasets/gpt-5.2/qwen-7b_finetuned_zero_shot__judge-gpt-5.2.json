[
  {
    "input": "The collaborative robot can guarantee that it will keep running the cycle until a stop is requested.",
    "gold": "<<Cobot>>(cycle_running U stop_requested)",
    "prediction": "<<Cobot>>(running_cycle U stop_requested)",
    "correct": "yes",
    "reasoning": "Same coalition (Cobot) and same until structure; 'running_cycle' is a clear alias of 'cycle_running' from the sentence.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The robotic arm can guarantee that if the object is fragile, then it will never exceed a maximum force.",
    "gold": "<<Arm>>G (fragile_object -> G !force_over_limit)",
    "prediction": "<<Arm>>G (object_fragile -> G !force_over_max)",
    "correct": "yes",
    "reasoning": "Same coalition (Arm) and same temporal structure: globally, if the object is fragile then globally the force is not over the limit. Predicate names are clear aliases (fragile_object/object_fragile, force_over_limit/force_over_max) without changing polarity.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The agricultural system can guarantee that if the soil is dry, then at the next step it will enable irrigation.",
    "gold": "<<AgriSystem>>G (soil_dry -> X irrigation_on)",
    "prediction": "<<AgriSystem>>G (soil_dry -> X irrigation_on)",
    "correct": "yes",
    "reasoning": "Exact match (normalized).",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "exact"
  },
  {
    "input": "The drone can guarantee that it will keep holding altitude until it receives a descend command.",
    "gold": "<<Drone>>(holding_altitude U descend_command)",
    "prediction": "<<Drone>>(holding_altitude U descend_command_received)",
    "correct": "no",
    "reasoning": "The gold requires holding_altitude until the proposition descend_command becomes true. The prediction uses a different condition descend_command_received, which is not a clear alias of descend_command and changes when the until condition is satisfied.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The security system can guarantee that it will keep monitoring until the threat is removed.",
    "gold": "<<SecuritySystem>>(monitoring U threat_removed)",
    "prediction": "<<SecuritySystem>>(monitoring U threat_removed)",
    "correct": "yes",
    "reasoning": "Exact match (normalized).",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "exact"
  },
  {
    "input": "The logistics system can guarantee that sooner or later the delivery will be completed.",
    "gold": "<<LogisticsSystem>>F delivery_done",
    "prediction": "<<LogisticsSystem>>F delivery_completed",
    "correct": "yes",
    "reasoning": "Same coalition (LogisticsSystem) and same temporal operator F (eventually). Predicate delivery_completed is a clear synonym of delivery_done from the sentence.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The smart city system can guarantee that if an intersection is congested, then at the next step it will retime the traffic lights.",
    "gold": "<<CitySystem>>G (junction_congested -> X lights_retimed)",
    "prediction": "<<CitySystem>>G (intersection_congested -> X traffic_retimed)",
    "correct": "yes",
    "reasoning": "Same coalition (CitySystem) and same temporal structure G( p -> X q ). The predicate names are consistent paraphrases: intersection/junction congested and retiming traffic lights.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if the safety barrier is on, then it will always remain stopped.",
    "gold": "<<Cobot>>G (safety_barrier_on -> G stopped)",
    "prediction": "<<Cobot>>G (safety_barrier_on -> G stopped)",
    "correct": "yes",
    "reasoning": "Exact match (normalized).",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "exact"
  },
  {
    "input": "The system can guarantee that if an intruder is detected, then at the next step it will send an alarm.",
    "gold": "<<System>>G (intruder_detected -> X alarm_sent)",
    "prediction": "<<System>>G (intruder_detected -> X alarm_sent)",
    "correct": "yes",
    "reasoning": "Exact match (normalized).",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "exact"
  },
  {
    "input": "The collaborative robot can guarantee that if a stop is requested, then at the next step it will stop moving.",
    "gold": "<<Cobot>>G (stop_requested -> X stopped)",
    "prediction": "<<Cobot>>G (stop_requested -> X !moving)",
    "correct": "no",
    "reasoning": "Gold requires that after a stop request, the next state satisfies predicate stopped. Prediction instead requires next state satisfies !moving. While related, !moving is not semantically equivalent to stopped (could be not moving without being in the stopped state), so the expressed property differs.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The robotic arm can guarantee that if the gripper is closed, then sooner or later the object will be lifted.",
    "gold": "<<Arm>>G (gripper_closed -> F object_lifted)",
    "prediction": "<<Arm>>G (gripper_closed -> F object_lifted)",
    "correct": "yes",
    "reasoning": "Exact match (normalized).",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "exact"
  },
  {
    "input": "The Mars rover can guarantee that sooner or later it will reach the sampling site.",
    "gold": "<<Rover>>F at_sampling_site",
    "prediction": "<<Rover>>F at_sampling_site",
    "correct": "yes",
    "reasoning": "Exact match (normalized).",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "exact"
  },
  {
    "input": "The system can guarantee that it will keep monitoring until the observation window ends.",
    "gold": "<<System>>(monitoring U window_closed)",
    "prediction": "<<System>>(monitoring U observation_window_end)",
    "correct": "yes",
    "reasoning": "Same coalition (System) and same until structure: monitoring holds until the window ends. The predicate names window_closed vs observation_window_end are clear aliases for the observation window ending.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The machine can guarantee that the system remains safe until cancellation is requested.",
    "gold": "<<Machine>>(safe U cancel)",
    "prediction": "<<Machine>>(safe U cancellation_requested)",
    "correct": "yes",
    "reasoning": "Same coalition (Machine) and same until structure requiring safety to hold up to the point cancellation is requested; 'cancel' and 'cancellation_requested' are equivalent predicates for the described event.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The industrial system can guarantee that sooner or later production will be completed.",
    "gold": "<<IndustrySystem>>F production_done",
    "prediction": "<<IndustrySystem>>F production_completed",
    "correct": "yes",
    "reasoning": "Same coalition (industrial system) and same temporal operator F expressing eventual completion; 'production_completed' is a clear synonym of 'production_done' from the sentence.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system and the teacher together can guarantee that sooner or later the student will be certified.",
    "gold": "<<EduSystem,Teacher>>F certified",
    "prediction": "<<EduSystem,Teacher>>F student_certified",
    "correct": "yes",
    "reasoning": "Same coalition {EduSystem,Teacher} and same eventuality operator F. Predicate 'student_certified' is a clear alias of 'certified' for the student mentioned in the sentence.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The industrial system can guarantee that if a machine overheats, then at the next step it will shut down.",
    "gold": "<<IndustrySystem>>G (overheating -> X shutdown)",
    "prediction": "<<IndustrySystem>>G (machine_overheated -> X production_stopped)",
    "correct": "no",
    "reasoning": "Although the coalition and temporal structure (G with implication to X) match, the atomic propositions differ in meaning: gold requires next-step shutdown after overheating, while prediction requires next-step production_stopped after machine_overheated. 'shutdown' is not a clear alias of 'production_stopped', so the property is changed.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if a human enters the area, then at the next step it will reduce speed.",
    "gold": "<<Cobot>>G (human_in_area -> X speed_low)",
    "prediction": "<<Cobot>>G (human_entered -> X speed_low)",
    "correct": "no",
    "reasoning": "Predicate mismatch: gold conditions on the human being in the area (human_in_area), while prediction uses an event of entering (human_entered). These are not semantically equivalent in general, so the trigger condition is changed.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The surveillance system can guarantee that sooner or later it will archive the logs after the shift ends.",
    "gold": "<<System>>F logs_archived",
    "prediction": "<<SurveillanceSystem>>F archived",
    "correct": "no",
    "reasoning": "Although both use an eventuality (F), the gold formula only states that logs are eventually archived, while the prediction uses a different atomic proposition ('archived' vs 'logs_archived') and does not clearly preserve the specific meaning about archiving the logs. Also, the input mentions 'after the shift ends', which is not captured in either, so we cannot treat the predicate change as a safe alias.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The surveillance system can guarantee that if an intruder enters the area, then sooner or later it will detect the intruder.",
    "gold": "<<System>>G (intruder_entered -> F intruder_detected)",
    "prediction": "<<SurveillanceSystem>>G (intruder_entered -> F detected)",
    "correct": "yes",
    "reasoning": "Same coalition (surveillance system) and same temporal structure: globally, if an intruder enters then eventually detection occurs. Predicate 'detected' is a clear alias of 'intruder_detected' in context.",
    "judge_model": "gpt-5.2",
    "source_file": "qwen-7b_finetuned_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  }
]