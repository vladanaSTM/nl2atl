[
  {
    "input": "The collaborative robot can guarantee that it will keep running the cycle until a stop is requested.",
    "gold": "<<Cobot>>(cycle_running U stop_requested)",
    "prediction": "<<CollaborativeRobot>> (running W stopRequested)",
    "correct": "no",
    "reasoning": "Gold uses strong until (U): cycle_running must hold until stop_requested occurs, and stop_requested is required to eventually happen. Prediction uses weak until (W): running may hold forever even if stopRequested never occurs. This changes the semantic guarantee.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The robotic arm can guarantee that if the object is fragile, then it will never exceed a maximum force.",
    "gold": "<<Arm>>G (fragile_object -> G !force_over_limit)",
    "prediction": "<<RoboticArm>> G (fragile -> G !exceed_max_force)",
    "correct": "yes",
    "reasoning": "Same coalition (Arm vs RoboticArm) and same temporal structure: globally, if the object is fragile then globally the force limit is not exceeded. Predicate names are clear paraphrases (fragile_object/fragile, force_over_limit/exceed_max_force).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The agricultural system can guarantee that if the soil is dry, then at the next step it will enable irrigation.",
    "gold": "<<AgriSystem>>G (soil_dry -> X irrigation_on)",
    "prediction": "<<AgriSys>> G (soil_dry -> X irrigation_enabled)",
    "correct": "yes",
    "reasoning": "Coalition refers to the same agricultural system (AgriSystem vs AgriSys). The formula keeps the global implication structure and the next-step requirement. Predicate irrigation_enabled is a clear alias of enabling irrigation/irrigation_on in the sentence.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The drone can guarantee that it will keep holding altitude until it receives a descend command.",
    "gold": "<<Drone>>(holding_altitude U descend_command)",
    "prediction": "<<Drone>>(hold_altitude W receive_descend_command)",
    "correct": "no",
    "reasoning": "Gold uses strong until (U): holding_altitude must continue until descend_command occurs, and the command is required to eventually happen. Prediction uses weak until (W), which allows hold_altitude to hold forever even if receive_descend_command never occurs. This changes the semantic guarantee.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The security system can guarantee that it will keep monitoring until the threat is removed.",
    "gold": "<<SecuritySystem>>(monitoring U threat_removed)",
    "prediction": "<<SecuritySystem>>(monitoring W threat_removed)",
    "correct": "no",
    "reasoning": "Gold uses strong until (U): threat_removed must eventually occur and monitoring holds until then. Prediction uses weak until (W): allows monitoring to hold forever even if threat_removed never happens. This changes the guaranteed property.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The logistics system can guarantee that sooner or later the delivery will be completed.",
    "gold": "<<LogisticsSystem>>F delivery_done",
    "prediction": "<<LogisticsSystem>> F delivery_completed",
    "correct": "yes",
    "reasoning": "Same coalition (LogisticsSystem) and same temporal operator F expressing eventual completion; predicate delivery_completed is a clear alias of delivery_done from the sentence.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The smart city system can guarantee that if an intersection is congested, then at the next step it will retime the traffic lights.",
    "gold": "<<CitySystem>>G (junction_congested -> X lights_retimed)",
    "prediction": "<<SmartCitySystem>> G (congested -> X retimeTrafficLights)",
    "correct": "yes",
    "reasoning": "Same coalition (smart city system) and same temporal structure: globally, if congestion holds then in the next step lights are retimed. Predicate names are clear paraphrases (intersection/junction congested; retime traffic lights/lights retimed).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if the safety barrier is on, then it will always remain stopped.",
    "gold": "<<Cobot>>G (safety_barrier_on -> G stopped)",
    "prediction": "<<Robot>> G (barrier_on -> stopped)",
    "correct": "no",
    "reasoning": "Coalition differs (<<Cobot>> vs <<Robot>>), and the temporal structure is weakened: gold requires globally that whenever the barrier is on, then from that point on it is always stopped (G (p -> G q)), while prediction only states globally (p -> q) at the same time step without the inner G persistence.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system can guarantee that if an intruder is detected, then at the next step it will send an alarm.",
    "gold": "<<System>>G (intruder_detected -> X alarm_sent)",
    "prediction": "<<System>> G(intruder_detected -> X alarm)",
    "correct": "no",
    "reasoning": "Temporal structure and coalition match, but the atomic proposition differs: gold requires alarm_sent, while prediction uses alarm. Without an explicit alias/equivalence, this changes the stated property.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if a stop is requested, then at the next step it will stop moving.",
    "gold": "<<Cobot>>G (stop_requested -> X stopped)",
    "prediction": "<<CollaborativeRobot>> G (stop_requested -> X stop_moving)",
    "correct": "yes",
    "reasoning": "Same coalition (collaborative robot/Cobot) and same temporal structure G(stop_requested -> X ...). The predicate 'stop_moving' matches the intended meaning of 'stopped' in context (stopping movement at the next step).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The robotic arm can guarantee that if the gripper is closed, then sooner or later the object will be lifted.",
    "gold": "<<Arm>>G (gripper_closed -> F object_lifted)",
    "prediction": "<<RoboticArm>> G (gripper_closed -> F object_lifted)",
    "correct": "yes",
    "reasoning": "Same coalition (Arm vs RoboticArm is an alias) and same temporal structure: globally, if gripper_closed then eventually object_lifted.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The Mars rover can guarantee that sooner or later it will reach the sampling site.",
    "gold": "<<Rover>>F at_sampling_site",
    "prediction": "<<MarsRover>> F sampling_site",
    "correct": "yes",
    "reasoning": "Same coalition (Mars rover/Rover) and same temporal operator F expressing eventual reach; atomic proposition is a clear alias (at_sampling_site vs sampling_site).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system can guarantee that it will keep monitoring until the observation window ends.",
    "gold": "<<System>>(monitoring U window_closed)",
    "prediction": "<<System>> (monitoring W observation_window_ends)",
    "correct": "no",
    "reasoning": "Gold uses strong until (U), requiring window_closed to eventually occur; prediction uses weak until (W), which allows monitoring forever even if the observation window never ends. Also the end-condition predicate differs (window_closed vs observation_window_ends) and is not clearly an alias.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The machine can guarantee that the system remains safe until cancellation is requested.",
    "gold": "<<Machine>>(safe U cancel)",
    "prediction": "<<Machine>> (safe W cancelRequested)",
    "correct": "no",
    "reasoning": "Gold requires strong until: safe must hold up to a point where cancel occurs (cancel is required to eventually happen). Prediction uses weak until (W), which allows safe to hold forever even if cancellation is never requested. Also the cancel proposition name differs (cancel vs cancelRequested) and is not clearly an alias.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The industrial system can guarantee that sooner or later production will be completed.",
    "gold": "<<IndustrySystem>>F production_done",
    "prediction": "<<IndustrialSystem>>F(production_completed)",
    "correct": "yes",
    "reasoning": "Same eventuality operator F under the system coalition; predicates production_done vs production_completed are clear synonyms for completion of production.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system and the teacher together can guarantee that sooner or later the student will be certified.",
    "gold": "<<EduSystem,Teacher>>F certified",
    "prediction": "<<System,Teacher>> F (student_certified)",
    "correct": "yes",
    "reasoning": "Coalition matches the system+teacher intent (EduSystem vs System is an alias), and both use the eventuality operator F for certification; predicate certified vs student_certified is a clear naming variant.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The industrial system can guarantee that if a machine overheats, then at the next step it will shut down.",
    "gold": "<<IndustrySystem>>G (overheating -> X shutdown)",
    "prediction": "<<IndustrialSystem>> G (overheat -> X shutdown)",
    "correct": "yes",
    "reasoning": "Coalition matches the industrial system, and the temporal structure is the same: globally, if overheating occurs then in the next step shutdown holds. Predicate names are clear aliases (overheating/overheat).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if a human enters the area, then at the next step it will reduce speed.",
    "gold": "<<Cobot>>G (human_in_area -> X speed_low)",
    "prediction": "<<Robot>> G (human_enters_area -> X reduce_speed)",
    "correct": "no",
    "reasoning": "Coalition/agent differs (<<Cobot>> vs <<Robot>>), and the atomic propositions are not clear aliases: gold requires next-step speed_low when human_in_area holds, while prediction uses human_enters_area and reduce_speed, which change the stated condition/effect.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The surveillance system can guarantee that sooner or later it will archive the logs after the shift ends.",
    "gold": "<<System>>F logs_archived",
    "prediction": "<<SurveillanceSystem>> G (shift_end -> F archive_logs)",
    "correct": "no",
    "reasoning": "Gold states the system can ensure that eventually logs are archived (<<System>>F logs_archived) with no condition. Prediction instead requires that always, if shift_end occurs then eventually archive_logs (<<SurveillanceSystem>>G(shift_end -> F archive_logs)), adding a shift_end condition and a global implication, which changes the meaning.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The surveillance system can guarantee that if an intruder enters the area, then sooner or later it will detect the intruder.",
    "gold": "<<System>>G (intruder_entered -> F intruder_detected)",
    "prediction": "<<SurveillanceSystem>> G (intruder_enters_area -> F detect_intruder)",
    "correct": "yes",
    "reasoning": "Same coalition (surveillance system) and same temporal structure: globally, if an intruder enters, then eventually the intruder is detected. Predicate names are clear paraphrases.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-5_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  }
]