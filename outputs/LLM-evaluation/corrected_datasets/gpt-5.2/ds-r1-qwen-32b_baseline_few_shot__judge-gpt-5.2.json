[
  {
    "input": "The collaborative robot can guarantee that it will keep running the cycle until a stop is requested.",
    "gold": "<<Cobot>>(cycle_running U stop_requested)",
    "prediction": "<<CollaborativeRobot>>(running_cycle U stop_requested)",
    "correct": "yes",
    "reasoning": "Coalition refers to the collaborative robot in both, and the temporal structure is the same: running the cycle holds until stop is requested. Predicate names are clear paraphrases.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The robotic arm can guarantee that if the object is fragile, then it will never exceed a maximum force.",
    "gold": "<<Arm>>G (fragile_object -> G !force_over_limit)",
    "prediction": "<<RoboticArm>>G (fragile_object -> !X(max_force))",
    "correct": "no",
    "reasoning": "Gold requires: always, if the object is fragile then from that point on it is always not over the force limit (nested G !force_over_limit). Prediction instead states: always, if fragile then not at the next step max_force holds (!X(max_force)), which is only a one-step constraint and uses a different predicate (max_force vs force_over_limit). Temporal meaning is weaker/different.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The agricultural system can guarantee that if the soil is dry, then at the next step it will enable irrigation.",
    "gold": "<<AgriSystem>>G (soil_dry -> X irrigation_on)",
    "prediction": "<<AgriculturalSystem>>G (dry_soil -> X irrigation_enabled)",
    "correct": "yes",
    "reasoning": "Same coalition (AgriSystem vs AgriculturalSystem) and same temporal structure G( -> X ). Predicates are clear aliases: soil_dry ≈ dry_soil and irrigation_on ≈ irrigation_enabled.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The drone can guarantee that it will keep holding altitude until it receives a descend command.",
    "gold": "<<Drone>>(holding_altitude U descend_command)",
    "prediction": "<<Drone>>(holding_altitude U descend_command)",
    "correct": "yes",
    "reasoning": "Exact match (normalized).",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "exact"
  },
  {
    "input": "The security system can guarantee that it will keep monitoring until the threat is removed.",
    "gold": "<<SecuritySystem>>(monitoring U threat_removed)",
    "prediction": "<<SecuritySystem>>(monitoring U threat_removed)",
    "correct": "yes",
    "reasoning": "Exact match (normalized).",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "exact"
  },
  {
    "input": "The logistics system can guarantee that sooner or later the delivery will be completed.",
    "gold": "<<LogisticsSystem>>F delivery_done",
    "prediction": "<<LogisticsSystem>>F delivery_completed",
    "correct": "yes",
    "reasoning": "Same coalition (LogisticsSystem) and same temporal operator F (eventually). Predicate delivery_completed is a clear synonym of delivery_done from the sentence.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The smart city system can guarantee that if an intersection is congested, then at the next step it will retime the traffic lights.",
    "gold": "<<CitySystem>>G (junction_congested -> X lights_retimed)",
    "prediction": "<<SmartCitySystem>>G (congested -> X retime_traffic_lights)",
    "correct": "yes",
    "reasoning": "Same coalition (smart city system/city system) and same temporal structure G( p -> X q ). Predicates are straightforward aliases: intersection/junction congested and retime traffic lights/lights retimed.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if the safety barrier is on, then it will always remain stopped.",
    "gold": "<<Cobot>>G (safety_barrier_on -> G stopped)",
    "prediction": "<<CollaborativeRobot>>G (safety_barrier_on -> stopped)",
    "correct": "no",
    "reasoning": "Gold requires that whenever the safety barrier is on, the robot is stopped forever after (nested G: safety_barrier_on -> G stopped). Prediction only enforces being stopped at the same time the barrier is on (safety_barrier_on -> stopped) without guaranteeing it remains stopped thereafter.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system can guarantee that if an intruder is detected, then at the next step it will send an alarm.",
    "gold": "<<System>>G (intruder_detected -> X alarm_sent)",
    "prediction": "<<System>>G (detect_intruder -> X send_alarm)",
    "correct": "yes",
    "reasoning": "Same coalition (System) and same temporal structure G( p -> X q ); predicate names are clear paraphrases of intruder_detected and alarm_sent.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if a stop is requested, then at the next step it will stop moving.",
    "gold": "<<Cobot>>G (stop_requested -> X stopped)",
    "prediction": "<<CollaborativeRobot>>G (stop_requested -> X stop_moving)",
    "correct": "yes",
    "reasoning": "Coalition refers to the same actor (collaborative robot/Cobot). Temporal structure matches: globally, if stop is requested then next step it stops. Predicate names 'stopped' vs 'stop_moving' are consistent with the described stopping of movement.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The robotic arm can guarantee that if the gripper is closed, then sooner or later the object will be lifted.",
    "gold": "<<Arm>>G (gripper_closed -> F object_lifted)",
    "prediction": "<<RoboticArm>>G (gripper_closed -> F object_lifted)",
    "correct": "yes",
    "reasoning": "Same coalition (Arm vs RoboticArm) and identical temporal structure: globally, if gripper_closed then eventually object_lifted.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The Mars rover can guarantee that sooner or later it will reach the sampling site.",
    "gold": "<<Rover>>F at_sampling_site",
    "prediction": "<<MarsRover>>F reach_sampling_site",
    "correct": "yes",
    "reasoning": "Same coalition (Mars rover/Rover) and same eventuality operator F; the predicate 'reach_sampling_site' matches the intended meaning of eventually being at the sampling site.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system can guarantee that it will keep monitoring until the observation window ends.",
    "gold": "<<System>>(monitoring U window_closed)",
    "prediction": "<<System>>G (monitoring U observation_window_end)",
    "correct": "no",
    "reasoning": "Gold requires an until property from the current state: monitoring holds up to when the window closes. Prediction adds an outer G, requiring this until condition to hold at all times, which is stronger and changes the meaning. Also the end condition predicate differs (window_closed vs observation_window_end) and is not a clear alias.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The machine can guarantee that the system remains safe until cancellation is requested.",
    "gold": "<<Machine>>(safe U cancel)",
    "prediction": "<<Machine>>G (safe U cancellation_requested)",
    "correct": "no",
    "reasoning": "Gold requires <<Machine>>(safe U cancel) as a single until property. The prediction adds an outer G, requiring (safe U cancellation_requested) to hold at every state, which is strictly stronger/different. Also the cancel proposition name differs (cancel vs cancellation_requested) and is not clearly an alias.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The industrial system can guarantee that sooner or later production will be completed.",
    "gold": "<<IndustrySystem>>F production_done",
    "prediction": "<<IndustrialSystem>>F production_completed",
    "correct": "yes",
    "reasoning": "Both formulas state that the industrial system has a strategy to eventually achieve completion of production (F). The coalition name and proposition are clear aliases (IndustrySystem/IndustrialSystem; production_done/production_completed) with no change in temporal structure or polarity.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system and the teacher together can guarantee that sooner or later the student will be certified.",
    "gold": "<<EduSystem,Teacher>>F certified",
    "prediction": "<<System,Teacher>>F certified_student",
    "correct": "no",
    "reasoning": "The coalition in the gold is <<EduSystem,Teacher>> while the prediction uses <<System,Teacher>>; this is not a clear alias from the sentence. Also the proposition differs (certified vs certified_student), changing the stated property.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The industrial system can guarantee that if a machine overheats, then at the next step it will shut down.",
    "gold": "<<IndustrySystem>>G (overheating -> X shutdown)",
    "prediction": "<<IndustrialSystem>>G (overheats -> X shutdown)",
    "correct": "yes",
    "reasoning": "Coalition is the industrial system in both (IndustrySystem vs IndustrialSystem is a naming variant). Temporal structure matches: globally, if overheating occurs then next step shutdown. Predicate overheats/overheating are clear aliases.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if a human enters the area, then at the next step it will reduce speed.",
    "gold": "<<Cobot>>G (human_in_area -> X speed_low)",
    "prediction": "<<CollaborativeRobot>>G (human_enters_area -> X reduce_speed)",
    "correct": "yes",
    "reasoning": "Coalition matches (CollaborativeRobot as Cobot). Both formulas state globally that if a human enters/is in the area, then in the next step the robot reduces speed (speed_low/reduce_speed are equivalent).",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The surveillance system can guarantee that sooner or later it will archive the logs after the shift ends.",
    "gold": "<<System>>F logs_archived",
    "prediction": "<<SurveillanceSystem>>G (shift_ends -> F archive_logs)",
    "correct": "no",
    "reasoning": "Gold states the system can ensure that eventually logs are archived (<<System>>F logs_archived) with no condition. Prediction instead requires that whenever the shift ends, eventually the logs will be archived (G(shift_ends -> F archive_logs)), adding a global implication and conditioning on shift_ends. This changes the temporal/connective structure and meaning.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The surveillance system can guarantee that if an intruder enters the area, then sooner or later it will detect the intruder.",
    "gold": "<<System>>G (intruder_entered -> F intruder_detected)",
    "prediction": "<<SurveillanceSystem>>G (intruder_enters -> F detect_intruder)",
    "correct": "yes",
    "reasoning": "Same coalition (surveillance system) and same temporal structure: globally, if an intruder enters then eventually the intruder is detected. Predicate names are clear paraphrases.",
    "judge_model": "gpt-5.2",
    "source_file": "ds-r1-qwen-32b_baseline_few_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  }
]