[
  {
    "input": "The collaborative robot can guarantee that it will keep running the cycle until a stop is requested.",
    "gold": "<<Cobot>>(cycle_running U stop_requested)",
    "prediction": "<<robot>> (running U stop_requested)",
    "correct": "yes",
    "reasoning": "Coalition refers to the collaborative robot (robot/Cobot) and the formula keeps the same until structure: running continues until stop is requested. Predicate names are reasonable aliases.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The robotic arm can guarantee that if the object is fragile, then it will never exceed a maximum force.",
    "gold": "<<Arm>>G (fragile_object -> G !force_over_limit)",
    "prediction": "<<RoboticArm>> G (fragile -> !exceed_max_force)",
    "correct": "no",
    "reasoning": "Gold requires a nested global: whenever the object is fragile, the arm can ensure it always (G) stays below the force limit thereafter. The prediction only states that if fragile then not exceed max force in the current state (missing the inner G), which is weaker. Predicate/agent renaming is fine, but the temporal structure is not.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The agricultural system can guarantee that if the soil is dry, then at the next step it will enable irrigation.",
    "gold": "<<AgriSystem>>G (soil_dry -> X irrigation_on)",
    "prediction": "<<agricultural_system>> G (soil_dry -> X irrigation_enabled)",
    "correct": "yes",
    "reasoning": "Same coalition (agricultural system) and same temporal structure G(-> X). Predicates irrigation_on vs irrigation_enabled are clear paraphrases of enabling irrigation.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The drone can guarantee that it will keep holding altitude until it receives a descend command.",
    "gold": "<<Drone>>(holding_altitude U descend_command)",
    "prediction": "<<drone>> (holding_altitude U receive_descend_command)",
    "correct": "yes",
    "reasoning": "Same coalition (Drone) and same until structure: maintaining holding_altitude until a descend command is received. Predicate receive_descend_command is a clear paraphrase of descend_command.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The security system can guarantee that it will keep monitoring until the threat is removed.",
    "gold": "<<SecuritySystem>>(monitoring U threat_removed)",
    "prediction": "<<security_system>>(monitoring W threat_removed)",
    "correct": "no",
    "reasoning": "Gold uses strong until (U): threat_removed must eventually occur and monitoring holds until then. Prediction uses weak until (W), which also allows monitoring to hold forever even if threat_removed never happens. This weakens the guarantee and changes the meaning.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The logistics system can guarantee that sooner or later the delivery will be completed.",
    "gold": "<<LogisticsSystem>>F delivery_done",
    "prediction": "<<logistics_system>>F(delivery_completed)",
    "correct": "yes",
    "reasoning": "Same coalition (logistics system) and same temporal operator F expressing eventual completion; predicate name is an obvious alias of delivery_done.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The smart city system can guarantee that if an intersection is congested, then at the next step it will retime the traffic lights.",
    "gold": "<<CitySystem>>G (junction_congested -> X lights_retimed)",
    "prediction": "<<SmartCitySystem>> G (congested_intersection -> X retime_traffic_lights)",
    "correct": "yes",
    "reasoning": "Same coalition (smart city system/city system) and same temporal structure: globally, if congestion holds then in the next step lights are retimed. Predicate names are clear paraphrases.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if the safety barrier is on, then it will always remain stopped.",
    "gold": "<<Cobot>>G (safety_barrier_on -> G stopped)",
    "prediction": "<<robot>> G (safety_barrier_on -> G stopped)",
    "correct": "yes",
    "reasoning": "Coalition refers to the collaborative robot; <<robot>> is an acceptable alias. Temporal structure matches: globally, if the safety barrier is on then globally stopped.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system can guarantee that if an intruder is detected, then at the next step it will send an alarm.",
    "gold": "<<System>>G (intruder_detected -> X alarm_sent)",
    "prediction": "<<System>> G (intruder_detected -> X alarm_sent)",
    "correct": "yes",
    "reasoning": "Prediction matches the gold formula exactly: same coalition <<System>>, same global condition G, same implication, and same next-step requirement X alarm_sent when intruder_detected holds.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if a stop is requested, then at the next step it will stop moving.",
    "gold": "<<Cobot>>G (stop_requested -> X stopped)",
    "prediction": "<<robot>> G (stop_requested -> X stopped)",
    "correct": "yes",
    "reasoning": "Same temporal structure G(stop_requested -> X stopped) and same intended agent; <<robot>> is a clear alias for the collaborative robot (Cobot) mentioned in the input.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The robotic arm can guarantee that if the gripper is closed, then sooner or later the object will be lifted.",
    "gold": "<<Arm>>G (gripper_closed -> F object_lifted)",
    "prediction": "<<robotic_arm>> G (gripper_closed -> F object_lifted)",
    "correct": "yes",
    "reasoning": "Same coalition (robotic arm/Arm) and same temporal structure: globally, if gripper_closed then eventually object_lifted. Only the agent name differs by alias/casing.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The Mars rover can guarantee that sooner or later it will reach the sampling site.",
    "gold": "<<Rover>>F at_sampling_site",
    "prediction": "<<MarsRover>>F sampling_site",
    "correct": "yes",
    "reasoning": "Same coalition (Mars rover/Rover) and same eventuality operator F; predicate sampling_site is a clear alias of at_sampling_site (reaching the sampling site).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system can guarantee that it will keep monitoring until the observation window ends.",
    "gold": "<<System>>(monitoring U window_closed)",
    "prediction": "<<System>> (monitoring U observation_window_ends)",
    "correct": "yes",
    "reasoning": "Same coalition (System) and same until structure: monitoring holds up to the point the observation window ends. The predicate names window_closed vs observation_window_ends are consistent paraphrases of the same event.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The machine can guarantee that the system remains safe until cancellation is requested.",
    "gold": "<<Machine>>(safe U cancel)",
    "prediction": "<<Machine>>(safe U cancel_requested)",
    "correct": "yes",
    "reasoning": "Same coalition (Machine) and same until structure (safe U ...). The predicate 'cancel_requested' is a clear alias/expansion of 'cancellation is requested' from the input, matching the intended meaning of cancel.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The industrial system can guarantee that sooner or later production will be completed.",
    "gold": "<<IndustrySystem>>F production_done",
    "prediction": "<<industrial_system>>F production_completed",
    "correct": "yes",
    "reasoning": "Same coalition (industrial system) and same temporal operator F expressing eventual completion; predicate names are clear aliases for production being completed.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The system and the teacher together can guarantee that sooner or later the student will be certified.",
    "gold": "<<EduSystem,Teacher>>F certified",
    "prediction": "<<system,teacher>> F certified_student",
    "correct": "no",
    "reasoning": "Although the coalition and eventuality operator F match the intent, the atomic proposition differs: gold requires eventual 'certified', while prediction asserts eventual 'certified_student'. This changes the stated property unless explicitly an alias, which is not given.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The industrial system can guarantee that if a machine overheats, then at the next step it will shut down.",
    "gold": "<<IndustrySystem>>G (overheating -> X shutdown)",
    "prediction": "<<industrial_system>> G (overheat -> X shutdown)",
    "correct": "yes",
    "reasoning": "Same coalition (industrial system) and same temporal structure: globally, if overheating occurs then in the next step shutdown holds. Predicate names are clear aliases (overheating/overheat).",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The collaborative robot can guarantee that if a human enters the area, then at the next step it will reduce speed.",
    "gold": "<<Cobot>>G (human_in_area -> X speed_low)",
    "prediction": "<<robot>> G (human_in_area -> X reduce_speed)",
    "correct": "yes",
    "reasoning": "Same coalition (collaborative robot) and same temporal structure G(human_in_area -> X ...). The predicate reduce_speed matches the described effect of reducing speed, corresponding to speed_low.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The surveillance system can guarantee that sooner or later it will archive the logs after the shift ends.",
    "gold": "<<System>>F logs_archived",
    "prediction": "<<SurveillanceSystem>> F (shift_ends -> F logs_archived)",
    "correct": "no",
    "reasoning": "Gold states the system can ensure logs_archived eventually (<<System>>F logs_archived) with no condition. Prediction instead requires that if shift_ends occurs then eventually logs_archived occurs (F(shift_ends -> F logs_archived)), which is weaker and can be satisfied even if shift_ends never happens; it also changes the temporal/conditional structure. Coalition name differs but could be an alias; the main issue is the added implication and nesting of F.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  },
  {
    "input": "The surveillance system can guarantee that if an intruder enters the area, then sooner or later it will detect the intruder.",
    "gold": "<<System>>G (intruder_entered -> F intruder_detected)",
    "prediction": "<<SurveillanceSystem>> G (intruder_enters_area -> F detected_intruder)",
    "correct": "yes",
    "reasoning": "Same coalition (surveillance system) and same temporal structure: globally, if an intruder enters, then eventually the intruder is detected. Predicate names are clear paraphrases.",
    "judge_model": "gpt-5.2",
    "source_file": "gpt-4.1_baseline_zero_shot.json",
    "match_method": "input",
    "decision_method": "llm"
  }
]