{
  "run_id": "llama-8b_finetuned_zero_shot_seed46",
  "git_commit": "55af891",
  "dataset_path": "./data/dataset.json",
  "total_samples": 61,
  "successful_predictions": 61,
  "failed_predictions": 0,
  "model": "meta-llama/Meta-Llama-3.1-8B-Instruct",
  "model_short": "llama-8b",
  "condition": "finetuned_zero_shot",
  "seed": 46,
  "finetuned": true,
  "few_shot": false,
  "num_epochs": 10,
  "learning_rate": 0.0002,
  "batch_size": 10,
  "num_few_shot": 0,
  "price_input_per_1k": null,
  "price_output_per_1k": null,
  "gpu_hour_usd": null,
  "price_input_per_token": null,
  "price_output_per_token": null,
  "latency_mean_ms": 1171.97,
  "latency_min_ms": 646.37,
  "latency_max_ms": 4036.15,
  "latency_total_ms": 71490.43,
  "latency_p50_ms": 1090.34,
  "latency_p95_ms": 1621.45,
  "latency_p99_ms": 2698.82,
  "timestamp_start": "2026-01-27T19:46:24Z",
  "timestamp_end": "2026-01-27T20:23:22Z",
  "duration_seconds": 2217.64,
  "metrics": {
    "n_examples": 61,
    "exact_match": 0.5081967213114754,
    "total_tokens_input": 9665,
    "total_tokens_output": 787,
    "total_tokens": 10452
  },
  "judge_model": "gpt-5.2",
  "source_file": "llama-8b_finetuned_zero_shot_seed46.json",
  "detailed_results": [
    {
      "input": "The industrial system can guarantee that a critical failure will never occur.",
      "gold": "<<IndustrySystem>>G !critical_failure",
      "prediction": "<<IndustrySystem>>G!critical_failure",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The autonomous vehicle can guarantee that sooner or later it will reach the destination.",
      "gold": "<<Vehicle>>F at_destination",
      "prediction": "<<Vehicle>>F at_destination",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The industrial system and the operator together can guarantee that sooner or later production will be restored.",
      "gold": "<<IndustrySystem,Operator>>F production_restored",
      "prediction": "<<IndustrySystem,Operator>>F production_restored",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The satellite and the ground station together can guarantee that sooner or later the data will be downloaded.",
      "gold": "<<Satellite,GroundStation>>F data_downloaded",
      "prediction": "<<Satellite,GroundStation>>F data_downloaded",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robot number 3 has a strategy to guarantee that they will reach position 2 in the next step.",
      "gold": "<<Robot3>> X pos2",
      "prediction": "<<Robot3>> X pos2",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The Romans, in the countries which they annexed, observed closely these measures; they sent colonies and maintained friendly relations with the minor powers, without increasing their strength; they kept down the greater, and did not allow any strong foreign powers to gain authority.",
      "gold": " <<Romans>>G(send-colony && friendly_with_minor_powers && keep_down_the_greater )",
      "prediction": "<<Roman_Empire>>G (!strong_foreign_power && G friendly_relations)",
      "correct": "no",
      "reasoning": "Prediction changes the coalition (Romans vs Roman_Empire) and the content/structure: the gold requires globally sending colonies AND being friendly with minor powers AND keeping down the greater. The prediction instead asserts globally no strong foreign power and redundantly nests G friendly_relations, omitting send-colony and keep_down_the_greater and altering the strong-foreign-power condition.",
      "decision_method": "llm"
    },
    {
      "input": "The network system can guarantee that critical packet loss will never occur.",
      "gold": "<<Network>>G !critical_packet_loss",
      "prediction": "<<Network>>G!critical_packet_loss",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robot number 3 has a strategy to force that eventually position 2 holds and never position 4 afterwards.",
      "gold": "<<Robot3>> F (pos2 && X G !pos4)",
      "prediction": "<<Robot3>> F (pos2 && G!pos4)",
      "correct": "no",
      "reasoning": "Gold requires that after reaching pos2, from the *next* step onward pos4 never holds (X G !pos4). Prediction omits the X, enforcing G !pos4 immediately at the pos2 state as well, which is a stronger/different property.",
      "decision_method": "llm"
    },
    {
      "input": "The system and the controller together can guarantee that sooner or later consumption will be reduced.",
      "gold": "<<ClimateSystem,Controller>>F consumption_reduced",
      "prediction": "<<CitySystem,Controller>>F consumption_reduced",
      "correct": "no",
      "reasoning": "Coalition mismatch: gold requires <<ClimateSystem,Controller>> but prediction uses <<CitySystem,Controller>>. Even with same F operator and proposition, changing the agent set changes the ATL ability statement.",
      "decision_method": "llm"
    },
    {
      "input": "Given three robots, none of them has a strategy to ensure that whenever position 2 holds, position 1 will hold in the next step.",
      "gold": "!<<Robot1>> G (pos2 -> X pos1) && !<<Robot2>> G (pos2 -> X pos1) && !<<Robot3>> G (pos2 -> X pos1)",
      "prediction": "<<Robot1>> G (pos2 -> X pos1) &&!<<Robot2>> G (pos2 -> X pos1) &&!<<Robot3>> G (pos2 -> X pos1)",
      "correct": "no",
      "reasoning": "The input says none of the three robots has such a strategy, so each conjunct must be negated. The prediction is missing the negation on Robot1 (it asserts Robot1 can guarantee the property), changing the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The collaborative robot can guarantee that if a stop is requested, then at the next step it will stop moving.",
      "gold": "<<Cobot>>G (stop_requested -> X stopped)",
      "prediction": "<<Cobot>>G (stop -> X stopped)",
      "correct": "no",
      "reasoning": "Predicate mismatch: the condition in the input/gold is stop_requested, but the prediction uses stop. Unless explicitly defined as an alias, this changes the meaning of when the obligation to stop applies.",
      "decision_method": "llm"
    },
    {
      "input": "The system and the administrator together can guarantee that sooner or later security will be restored.",
      "gold": "<<SecuritySystem,Admin>>F security_restored",
      "prediction": "<<System,Admin>>F security_restored",
      "correct": "no",
      "reasoning": "Coalition mismatch: gold specifies <<SecuritySystem,Admin>> while prediction uses <<System,Admin>>. Unless explicitly an alias, changing the agent name changes who has the ability, so the ATL meaning is not guaranteed to be the same.",
      "decision_method": "llm"
    },
    {
      "input": "The climate control system can guarantee that sooner or later the temperature will return to a stable state.",
      "gold": "<<ClimateSystem>>F temperature_stable",
      "prediction": "<<ClimateSystem>>F stable_temperature",
      "correct": "yes",
      "reasoning": "Same coalition (climate control system) and same temporal operator F expressing eventuality; predicate is a clear alias of 'temperature stable'.",
      "decision_method": "llm"
    },
    {
      "input": "The Parties agree that an armed attack against one or more of them in Europe or North America shall be considered an attack against them all and consequently they agree that, if such an armed attack occurs, each of them, in exercise of the right of individual or collective self-defence recognised by Article 51 of the Charter of the United Nations, will assist the Party or Parties so attacked by taking forthwith, individually and in concert with the other Parties, such action as it deems necessary, including the use of armed force, to restore and maintain the security of the North Atlantic area.",
      "gold": "<<Parties>>(attack U security_restored)",
      "prediction": "<<Parties>>G (armed_attack_in_europe_northamerica -> armed_force)",
      "correct": "no",
      "reasoning": "Gold states the Parties can ensure that, after an attack, the system proceeds until security is restored (U security_restored). The prediction instead is a global implication that whenever an armed attack occurs it leads to armed_force, with no until/restoration condition and a different temporal structure (G and -> vs U). It also narrows the response to armed force rather than 'such action as deemed necessary' aimed at restoring/maintaining security.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 has a strategy to guarantee that it will keep position 1 until move is true and while not attack.",
      "gold": "<<Robot1>> (pos1 U (move && !attack))",
      "prediction": "<<Robot1>> (pos1 U move &&!attack)",
      "correct": "no",
      "reasoning": "The prediction changes the formula’s structure due to missing parentheses: it parses as (pos1 U move) && !attack rather than pos1 U (move && !attack). This would require !attack to hold immediately and globally, not just at the termination condition of the until.",
      "decision_method": "llm"
    },
    {
      "input": "The satellite can guarantee that sooner or later it will establish a link with the ground station.",
      "gold": "<<Satellite>>F link_established",
      "prediction": "<<Satellite>>F link_established",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The machine can guarantee that if the payment does not occur, the ticket will never be printed.",
      "gold": "<<Machine>>G (!paid -> G !ticket_printed)",
      "prediction": "<<Machine>>G (!paid -> G!ticket_printed)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robotic arm can guarantee that if the object is grasped, then at the next step it will start transport.",
      "gold": "<<Arm>>G (object_grasped -> X transport_started)",
      "prediction": "<<Arm>>G (object_grasped -> X transport_started)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The autonomous vehicle can guarantee that it will never exceed the speed limit.",
      "gold": "<<Vehicle>>G !speed_over_limit",
      "prediction": "<<Vehicle>>G!speed_over_limit",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The control system can guarantee that it will keep regulating until the error becomes zero.",
      "gold": "<<ControlSystem>>(regulating U error_zero)",
      "prediction": "<<ControlSystem>>(regulating U error == 0)",
      "correct": "yes",
      "reasoning": "Same coalition (ControlSystem) and same until structure (regulating U ...). The predicate 'error == 0' is a clear syntactic variant of 'error_zero' meaning the error becomes zero.",
      "decision_method": "llm"
    },
    {
      "input": "The rover can guarantee that when it is ready to sample, at the next step it will start sampling.",
      "gold": "<<Rover>>G (ready_to_sample -> X sampling_started)",
      "prediction": "<<Rover>>G (ready_to_sample -> X sampling)",
      "correct": "no",
      "reasoning": "The gold requires that the next state satisfies the specific proposition sampling_started. The prediction uses a different atomic proposition sampling, which is not a clear alias of 'start sampling' and could mean 'is sampling' rather than 'has started sampling', changing the expressed property.",
      "decision_method": "llm"
    },
    {
      "input": "The mobile robot can guarantee that sooner or later it will reach the charging station.",
      "gold": "<<Robot>>F at_charging_station",
      "prediction": "<<Robot>>F at_charging_station",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The system and the operators together can guarantee that sooner or later the area will be secured.",
      "gold": "<<EmergencySystem,Operators>>F area_secured",
      "prediction": "<<System,Operators>>F area_secured",
      "correct": "no",
      "reasoning": "Coalition mismatch: gold specifies <<EmergencySystem,Operators>> while prediction uses <<System,Operators>>. Agent set must match; otherwise the ability is attributed to a different coalition.",
      "decision_method": "llm"
    },
    {
      "input": "Robots number 1 and number 2 together have a strategy to ensure in the next step not position 5 and not position 4.",
      "gold": "<<Robot1, Robot2>> X (!pos5 && !pos4)",
      "prediction": "<<Robot1, Robot2>> X (not pos5 && not pos4)",
      "correct": "yes",
      "reasoning": "Same coalition {Robot1, Robot2}, same next-step operator X, and same conjunction of negated propositions; 'not' is equivalent to '!' here.",
      "decision_method": "llm"
    },
    {
      "input": "The satellite can guarantee that it will keep adjusting attitude until the antenna is aligned.",
      "gold": "<<Satellite>>(adjusting_attitude U antenna_aligned)",
      "prediction": "<<Satellite>>(adjusting_attitude U antenna_aligned)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "Robots number 1 and number 2 have a joint strategy to always avoid position 3.",
      "gold": "<<Robot1, Robot2>> G !pos3",
      "prediction": "<<Robot1, Robot2>> G!pos3",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robot number 3 has a strategy to ensure that eventually position 2 holds and then in the next step position 1 holds.",
      "gold": "<<Robot3>> F (pos2 && X pos1)",
      "prediction": "<<Robot3>> F (pos2 && X pos1)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The coalition of robots 2 and 3 has a strategy to ensure that eventually either attack or defend holds and not retreat.",
      "gold": "<<Robot2, Robot3>> F ((attack || defend) && !retreat)",
      "prediction": "<<Robot2, Robot3>> F (attack || defend &&!retreat)",
      "correct": "no",
      "reasoning": "Gold requires eventually ((attack || defend) && !retreat), i.e., not retreat must hold together with either attack or defend. Prediction parses as F (attack || (defend && !retreat)) due to && binding tighter than ||, which allows attack even if retreat holds. This changes the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The Lord will fulfill his purpose for me.",
      "gold": "<<Lord>> F fulfilled",
      "prediction": "<<I>>(F purpose_fulfilled)",
      "correct": "no",
      "reasoning": "Coalition/agent is wrong: the statement attributes the eventual fulfillment to the Lord, but the prediction gives the ability to 'I'. Also the proposition differs ('fulfilled' vs 'purpose_fulfilled') and is not a clear alias given the gold.",
      "decision_method": "llm"
    },
    {
      "input": "Robots number 2 and number 3 have a strategy to guarantee that they will eventually reach position 1 and eventually reach position 2.",
      "gold": "<<Robot2, Robot3>> (F pos1 && F pos2)",
      "prediction": "<<Robot2, Robot3>> (F pos1 && F pos2)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robotic arm can guarantee that if it detects a collision, then at the next step it will stop.",
      "gold": "<<Arm>>G (collision_detected -> X stopped)",
      "prediction": "<<Arm>>G (collision -> X stopped)",
      "correct": "no",
      "reasoning": "Predicate mismatch: gold conditions on collision_detected, while prediction uses collision. This changes the meaning (detection event vs collision state) and cannot be assumed an alias from the sentence.",
      "decision_method": "llm"
    },
    {
      "input": "The recommender system can guarantee that it will keep learning until accuracy improves.",
      "gold": "<<Recommender>>(learning U accuracy_improved)",
      "prediction": "<<Recommender>>(learning U accuracyImproved)",
      "correct": "yes",
      "reasoning": "Same coalition (Recommender) and same until structure (learning U accuracy_improved). The predicate name accuracyImproved is a clear alias of accuracy_improved with no semantic change.",
      "decision_method": "llm"
    },
    {
      "input": "The robotic arm can guarantee that it will keep moving toward the target until it reaches it.",
      "gold": "<<Arm>>(moving_to_target U at_target)",
      "prediction": "<<Arm>>(moving U at_target)",
      "correct": "no",
      "reasoning": "The gold requires the arm to keep moving toward the target until at_target holds (moving_to_target U at_target). The prediction uses a different proposition moving, which is not necessarily equivalent to moving toward the target, so the expressed condition is weaker/different.",
      "decision_method": "llm"
    },
    {
      "input": "The drone can guarantee that if it loses GPS signal, then at the next step it will switch to inertial navigation.",
      "gold": "<<Drone>>G (gps_lost -> X inertial_nav_on)",
      "prediction": "<<Drone>>G (gps_lost -> X inertial_nav)",
      "correct": "no",
      "reasoning": "The gold requires that after GPS is lost, the next state has inertial navigation switched on (inertial_nav_on). The prediction uses a different atomic proposition (inertial_nav), which is not clearly an alias for the action/state of being switched on; this changes the expressed property unless explicitly defined equivalent.",
      "decision_method": "llm"
    },
    {
      "input": "The machine can guarantee that at the next step the ticket will be validated.",
      "gold": "<<Machine>>X ticket_validated",
      "prediction": "<<Machine>>X ticket_validated",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The machine can guarantee that if the ticket is printed, then sooner or later it will be validated.",
      "gold": "<<Machine>>G (ticket_printed -> F validated)",
      "prediction": "<<Machine>>G (ticket_printed -> F validated)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The machine can guarantee that the gate will never open without payment.",
      "gold": "<<Machine>>G (!paid -> !gate_open)",
      "prediction": "<<Machine>>G!gate_open -> G!payment_done",
      "correct": "no",
      "reasoning": "Gold states: always, if payment is not made then the gate is not open (gate_open implies paid). Prediction instead is an implication between two global properties: (<<Machine>>G !gate_open) -> (G !payment_done), which is not equivalent and even uses a different payment predicate polarity/meaning. It does not express 'never open without payment'.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 has a strategy to ensure that always eventually position 2 or always eventually position 3.",
      "gold": "<<Robot1>> (G F pos2 || G F pos3)",
      "prediction": "<<Robot1>> (G F pos2 || G F pos3)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The drone can guarantee that if the target is detected, then at the next step it will take a photo.",
      "gold": "<<Drone>>G (target_detected -> X photo_taken)",
      "prediction": "<<Drone>>G (target_detected -> X photo_taken)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The swarm can guarantee that if a drone fails, then at the next step it will reconfigure the formation.",
      "gold": "<<Swarm>>G (drone_failed -> X formation_reconfigured)",
      "prediction": "<<Swarm>>G (drone_fault -> X formation_reconfigured)",
      "correct": "no",
      "reasoning": "Predicate mismatch: gold conditions on drone_failed, while prediction uses drone_fault. Without an explicit alias/equivalence, this changes the triggering condition of the implication; coalition and temporal structure match but the meaning may differ.",
      "decision_method": "llm"
    },
    {
      "input": "The system and the user together can guarantee that sooner or later a good recommendation will be found.",
      "gold": "<<Recommender,User>>F good_recommendation",
      "prediction": "<<Recommender,User>>F good_recommendation",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The collaborative robot can guarantee that it will never cause a collision with a human.",
      "gold": "<<Cobot>>G !human_collision",
      "prediction": "<<Cobot>>G!collision_with_human",
      "correct": "yes",
      "reasoning": "Same coalition (Cobot) and same temporal structure G with negation. Predicate names human_collision vs collision_with_human are clear aliases for the same event.",
      "decision_method": "llm"
    },
    {
      "input": "Therefore, take me and bind me to the crosspiece half way up the mast; bind me as I stand upright, with a bond so fast that I cannot possibly break away, and lash the rope’s ends to the mast itself. If I beg and pray you to set me free, then bind me more tightly still.",
      "gold": "<<Odysseus>>G(binded && praying -> bind_tightly)",
      "prediction": "<<Achilles>>(G (stand upright && G!break away))",
      "correct": "no",
      "reasoning": "Coalition/agent is wrong (Achilles vs Odysseus). The temporal/conditional structure is changed: gold is a global implication about if bound and praying then bind tighter, while prediction asserts globally standing upright and globally not breaking away, with no implication to bind tighter when praying.",
      "decision_method": "llm"
    },
    {
      "input": "The warehouse and the courier together can guarantee that sooner or later the package will be shipped.",
      "gold": "<<Warehouse,Courier>>F package_shipped",
      "prediction": "<<Warehouse,Courier>>F package_shipped",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robot number 1 does not have a strategy to ensure that position 3 will eventually hold when position 2 holds now.",
      "gold": "!<<Robot1>> (pos2 -> F pos3)",
      "prediction": "<<Robot1>> F (pos2 -> pos3)",
      "correct": "no",
      "reasoning": "Gold states Robot1 lacks a strategy to ensure: if pos2 holds now then eventually pos3 holds (!<<Robot1>>(pos2 -> F pos3)). Prediction instead asserts Robot1 has a strategy to eventually reach a state where (pos2 -> pos3) holds (<<Robot1>>F(pos2 -> pos3)), missing the outer negation, changing the temporal structure, and weakening the condition (it can be satisfied trivially when pos2 is false).",
      "decision_method": "llm"
    },
    {
      "input": "The security system can guarantee that unauthorized access will never occur.",
      "gold": "<<SecuritySystem>>G !unauthorized_access",
      "prediction": "<<SecuritySystem>>G!unauthorized_access",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robots number 1 and number 2 do not  have a strategy to ensure that they will reach position 2 in the next step.",
      "gold": "!<<Robot1, Robot2>> X pos2",
      "prediction": "<<Robot1, Robot2>> X pos2",
      "correct": "no",
      "reasoning": "The input and gold state that Robots 1 and 2 do NOT have a strategy to ensure reaching pos2 next step (negated ability: !<<Robot1, Robot2>> X pos2). The prediction omits the negation and asserts they DO have such a strategy, reversing the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The drone can guarantee that if it enters return mode, then it will never land outside the base.",
      "gold": "<<Drone>>G (return_mode -> G !landed_outside_base)",
      "prediction": "<<Drone>>G (return_mode -> G!landing_outside_base)",
      "correct": "yes",
      "reasoning": "Same coalition (Drone) and same temporal structure: globally, if return_mode holds then globally not landing outside base. Predicate name variation (landed_outside_base vs landing_outside_base) is a clear alias; missing space in G! does not change meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 has a strategy to ensure that eventually reach position 1.",
      "gold": "<<Robot1>> F pos1",
      "prediction": "<<Robot1>> F pos1",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robotic arm can guarantee that it will keep aligning until the object is aligned.",
      "gold": "<<Arm>>(aligning U object_aligned)",
      "prediction": "<<Arm>>(aligning U object_aligned)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robotic arm can guarantee that if the target position changes, then at the next step it will start replanning.",
      "gold": "<<Arm>>G (target_changed -> X replanning)",
      "prediction": "<<Arm>>G (target_position_changed -> X replanning)",
      "correct": "yes",
      "reasoning": "Same coalition (Arm) and same temporal structure G( -> X ). The predicate target_position_changed is a clear alias of target_changed from the sentence, so the meaning is preserved.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 has a strategy to guarantee that it will eventually reach position 1 or position 2.",
      "gold": "<<Robot1>> F (pos1 || pos2)",
      "prediction": "<<Robot1>> F (pos1 || pos2)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "Robots number 2 and number 3 have a strategy to ensure that always not position 4.",
      "gold": "<<Robot2, Robot3>> G !pos4",
      "prediction": "<<Robot2, Robot3>> G!pos4",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The vehicle can guarantee that it will keep searching for parking until it finds a free spot.",
      "gold": "<<Vehicle>>(searching_parking U parking_found)",
      "prediction": "<<Vehicle>>(searching_for_parking U parking_found)",
      "correct": "yes",
      "reasoning": "Same coalition (Vehicle) and same until structure (U) with the same goal condition parking_found; searching_for_parking is a clear paraphrase of searching_parking.",
      "decision_method": "llm"
    },
    {
      "input": "The logistics system and the courier together can guarantee that sooner or later the package will be delivered.",
      "gold": "<<LogisticsSystem,Courier>>F package_delivered",
      "prediction": "<<LogisticsSystem,Courier>>F package_delivered",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The security system can guarantee that it will keep monitoring until the threat is removed.",
      "gold": "<<SecuritySystem>>(monitoring U threat_removed)",
      "prediction": "<<SecuritySystem>>(monitoring U threat_removed)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "Nobody else could have got in this way, as this entrance was meant only for you [K.]. Now I'll go and close it.",
      "gold": "<<K>>F enter",
      "prediction": "<<K>>G!others_entered_this_way",
      "correct": "no",
      "reasoning": "Gold states that coalition K can eventually enter (<<K>>F enter). Prediction instead states K can guarantee that others never entered this way (<<K>>G !others_entered_this_way), changing both the proposition and the temporal/strategic meaning; it does not express K's eventual entry.",
      "decision_method": "llm"
    },
    {
      "input": "The network system can guarantee that sooner or later the packet will be delivered.",
      "gold": "<<Network>>F packet_delivered",
      "prediction": "<<Network>>F packet_delivered",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The agricultural system can guarantee that if the soil is dry, then at the next step it will enable irrigation.",
      "gold": "<<AgriSystem>>G (soil_dry -> X irrigation_on)",
      "prediction": "<<AgriSystem>>G (soil_dry -> X irrigation_on)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robotic arm can guarantee that if the object is fragile, then it will never exceed a maximum force.",
      "gold": "<<Arm>>G (fragile_object -> G !force_over_limit)",
      "prediction": "<<Arm>>G (object_fragile -> G!force_over_max)",
      "correct": "yes",
      "reasoning": "Same coalition (Arm) and same temporal structure: globally, if the object is fragile then globally the force is not over the limit. Predicate names are clear aliases (fragile_object/object_fragile, force_over_limit/force_over_max), and the negation is preserved.",
      "decision_method": "llm"
    },
    {
      "input": "The game system can guarantee that a critical bug will never occur.",
      "gold": "<<GameSystem>>G !critical_bug",
      "prediction": "<<GameSystem>>G!critical_bug",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    }
  ]
}