{
  "run_id": "qwen-3b_finetuned_zero_shot_seed42",
  "git_commit": "92b55e7",
  "dataset_path": "./data/dataset.json",
  "total_samples": 61,
  "successful_predictions": 61,
  "failed_predictions": 0,
  "model": "Qwen/Qwen2.5-3B-Instruct",
  "model_short": "qwen-3b",
  "condition": "finetuned_zero_shot",
  "seed": 42,
  "finetuned": true,
  "few_shot": false,
  "num_epochs": 10,
  "learning_rate": 0.0002,
  "batch_size": 10,
  "num_few_shot": 0,
  "price_input_per_1k": null,
  "price_output_per_1k": null,
  "gpu_hour_usd": null,
  "price_input_per_token": null,
  "price_output_per_token": null,
  "latency_mean_ms": 435.11,
  "latency_min_ms": 235.41,
  "latency_max_ms": 1212.41,
  "latency_total_ms": 26541.75,
  "latency_p50_ms": 436.72,
  "latency_p95_ms": 607.99,
  "latency_p99_ms": 867.67,
  "timestamp_start": "2026-01-27T21:14:16Z",
  "timestamp_end": "2026-01-27T21:33:08Z",
  "duration_seconds": 1132.13,
  "metrics": {
    "n_examples": 61,
    "exact_match": 0.36065573770491804,
    "total_tokens_input": 9449,
    "total_tokens_output": 779,
    "total_tokens": 10228
  },
  "judge_model": "gpt-5.2",
  "source_file": "qwen-3b_finetuned_zero_shot_seed42.json",
  "detailed_results": [
    {
      "input": "The network system can guarantee that if a link fails, then at the next step it will reroute.",
      "gold": "<<Network>>G (link_failed -> X rerouting)",
      "prediction": "<<Network>>G (link_failed -> X rerouted)",
      "correct": "no",
      "reasoning": "The gold requires that after a link failure, the next state satisfies proposition rerouting. The prediction uses a different atomic proposition rerouted, which is not a clear alias (it changes the stated condition from being in the process of rerouting to having rerouted). Thus the meaning may differ.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 has a strategy to guarantee globally that position 2 implies eventually position 3.",
      "gold": "<<Robot1>> G (pos2 -> F pos3)",
      "prediction": "<<Robot1>> (pos2 -> F pos3)",
      "correct": "no",
      "reasoning": "Gold requires the implication to hold globally (G (pos2 -> F pos3)) on all states along the path. The prediction omits the outer G, so it only enforces the implication at the initial state, which is weaker.",
      "decision_method": "llm"
    },
    {
      "input": "The control system can guarantee that it will keep regulating until the error becomes zero.",
      "gold": "<<ControlSystem>>(regulating U error_zero)",
      "prediction": "<<ControlSystem>>(regulating U error_zero)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "Robots number 1 and number 3 together have a strategy to make sure that eventually position 2 holds and position 3 never holds afterwards.",
      "gold": "<<Robot1, Robot3>> F (pos2 && X G !pos3)",
      "prediction": "<<Robot1, Robot3>> F (pos2 && X G !pos3)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The rover can guarantee that if it detects a sandstorm, then at the next step it will enter shelter mode.",
      "gold": "<<Rover>>G (sandstorm_detected -> X shelter_mode)",
      "prediction": "<<Rover>>G (sandstorm -> X shelter_mode)",
      "correct": "no",
      "reasoning": "The antecedent predicate differs: gold requires sandstorm_detected, while prediction uses sandstorm. This changes the condition under which the rover must enter shelter mode, so the meaning is not preserved.",
      "decision_method": "llm"
    },
    {
      "input": "The drone can guarantee that if it enters return mode, then it will never land outside the base.",
      "gold": "<<Drone>>G (return_mode -> G !landed_outside_base)",
      "prediction": "<<Drone>>G (return_mode -> G !land_outside_base)",
      "correct": "yes",
      "reasoning": "Same coalition (Drone) and temporal structure: globally, if return_mode holds then globally not landing outside base. Predicate name difference (landed_outside_base vs land_outside_base) is a minor alias/typo that does not change the intended meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The management system and the manager together can guarantee that sooner or later the goal will be reached.",
      "gold": "<<ManagementSystem,Manager>>F goal_reached",
      "prediction": "<<ManagementSystem,Manager>>F goal_reached",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The education system can guarantee that sooner or later the student will complete the course.",
      "gold": "<<EduSystem>>F course_completed",
      "prediction": "<<EduSystem>>F course_completed",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The agricultural system can guarantee that sooner or later irrigation will be completed.",
      "gold": "<<AgriSystem>>F irrigation_done",
      "prediction": "<<AgriSystem>>F irrigation_done",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The coalition of robots 1 and 2 does not have a strategy to ensure that position 3 will hold globally.",
      "gold": "!<<Robot1, Robot2>> G pos3",
      "prediction": "<<Robot1, Robot2>> G pos3",
      "correct": "no",
      "reasoning": "The input and gold state that robots 1 and 2 do NOT have a strategy to ensure pos3 globally: !<<Robot1, Robot2>> G pos3. The prediction omits the outer negation and instead asserts they DO have such a strategy, which is the opposite meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The drone swarm can guarantee that it will never lose global connectivity.",
      "gold": "<<Swarm>>G !network_disconnected",
      "prediction": "<<Swarm>>G !global_disconnect",
      "correct": "yes",
      "reasoning": "Same coalition (Swarm) and same temporal requirement G with negation. The predicate global_disconnect is a clear alias of network_disconnected / losing global connectivity, so the meaning is preserved.",
      "decision_method": "llm"
    },
    {
      "input": "Nobody else could have got in this way, as this entrance was meant only for you [K.]. Now I'll go and close it.",
      "gold": "<<K>>F enter",
      "prediction": "<<Others>> F entrance_open",
      "correct": "no",
      "reasoning": "Gold says agent K has a strategy to eventually enter (<<K>>F enter). Prediction instead attributes an eventuality to a different coalition (<<Others>>) and changes the proposition from entering to the entrance being open. Both the agent set and the state property differ, so the meaning is not preserved.",
      "decision_method": "llm"
    },
    {
      "input": "The user can guarantee that at the next step the system will not time out.",
      "gold": "<<User>>X !timeout",
      "prediction": "<<User>>X !timeout",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The autonomous vehicle can guarantee that sooner or later it will reach the destination.",
      "gold": "<<Vehicle>>F at_destination",
      "prediction": "<<Vehicle>>F at_destination",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The warehouse can guarantee that if a shelf is empty, then at the next step it will request restocking.",
      "gold": "<<Warehouse>>G (shelf_empty -> X restock_requested)",
      "prediction": "<<Warehouse>>G (shelf_empty -> X restocked)",
      "correct": "no",
      "reasoning": "Predicate mismatch: the gold requires that the next step a restock is requested (restock_requested), while the prediction requires that the shelf is already restocked (restocked). This changes the meaning from making a request to achieving the restocked state.",
      "decision_method": "llm"
    },
    {
      "input": "The rover can guarantee that when it is ready to sample, at the next step it will start sampling.",
      "gold": "<<Rover>>G (ready_to_sample -> X sampling_started)",
      "prediction": "<<Rover>>G (ready_to_sample -> X sampling_started)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The mobile robot can guarantee that it will never enter a restricted zone.",
      "gold": "<<Robot>>G !in_restricted_zone",
      "prediction": "<<Robot>>G !in_restricted_zone",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The recommender system can guarantee that it will never suggest forbidden content.",
      "gold": "<<Recommender>>G !forbidden_content",
      "prediction": "<<Recommender>>G !suggested_forbidden_content",
      "correct": "no",
      "reasoning": "The gold formula forbids the state proposition forbidden_content from ever holding, while the prediction forbids suggested_forbidden_content. The input is specifically about never suggesting forbidden content, so the predicate must capture the act of suggesting; changing the atomic proposition changes the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 does not have a strategy to ensure that position 3 will eventually hold when position 2 holds now.",
      "gold": "!<<Robot1>> (pos2 -> F pos3)",
      "prediction": "<<Robot1>> (pos2 -> F pos3)",
      "correct": "no",
      "reasoning": "The input and gold state that Robot1 does NOT have a strategy (negated ability) to ensure the property. The prediction omits the leading negation, asserting that Robot1 DOES have such a strategy, which reverses the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The robotic arm can guarantee that if the target position changes, then at the next step it will start replanning.",
      "gold": "<<Arm>>G (target_changed -> X replanning)",
      "prediction": "<<Arm>>G (target_changed -> X replanning_started)",
      "correct": "yes",
      "reasoning": "Same coalition (Arm) and same temporal structure G(target_changed -> X ...). The predicate replanning_started is a clear alias of 'start replanning' in the input, matching the intended meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The mobile robot can guarantee that it will continue following the line until it reaches the loading area.",
      "gold": "<<Robot>>(following_line U at_loading_area)",
      "prediction": "<<Robot>>G (following_line U at_loading_area)",
      "correct": "no",
      "reasoning": "Gold requires the robot can enforce a single until condition: following_line holds up to the point at_loading_area becomes true. The prediction adds an outer G, requiring that on all future states the until condition holds again, which is strictly stronger/different (it would need to be able to repeatedly ensure reaching the loading area from every future point). Temporal structure changed.",
      "decision_method": "llm"
    },
    {
      "input": "The rover can guarantee that if it finds an interesting sample, then at the next step it will tag the sample.",
      "gold": "<<Rover>>G (interesting_sample -> X sample_tagged)",
      "prediction": "<<Rover>>G (found_sample -> X tagged_sample)",
      "correct": "no",
      "reasoning": "The antecedent predicate changes meaning: gold conditions on an interesting sample (interesting_sample), while prediction uses found_sample (mere finding). This is not a clear alias and weakens/changes the property, even though the agent and temporal structure match.",
      "decision_method": "llm"
    },
    {
      "input": "he [Odysseus] is a man of many resources, and even though he were in chains of iron he would find some way of getting home again.",
      "gold": "chains_of_iron -> <<Odysseus>>F(reach_home)",
      "prediction": "<<Odysseus>>G(chained -> home)",
      "correct": "no",
      "reasoning": "Gold states a conditional: if Odysseus is in chains of iron, then he can eventually reach home (chains_of_iron -> <<Odysseus>>F reach_home). Prediction instead asserts Odysseus can guarantee always (G) that if chained then home holds (or that chained implies home at all times), which is much stronger and changes both the temporal operator (F vs G) and the conditional structure.",
      "decision_method": "llm"
    },
    {
      "input": "Robots number 1 and number 2 together have a strategy to ensure in the next step not position 5 and not position 4.",
      "gold": "<<Robot1, Robot2>> X (!pos5 && !pos4)",
      "prediction": "<<Robot1, Robot2>> X !pos5 && !pos4",
      "correct": "no",
      "reasoning": "Gold requires both !pos5 and !pos4 to hold at the next step under the coalition’s strategy: <<R1,R2>> X(!pos5 && !pos4). The prediction parses as (<<R1,R2>> X !pos5) && !pos4, which enforces !pos4 immediately (outside X and outside the strategy modality) rather than at the next step under the coalition’s control. This changes the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The vehicle can guarantee that if a sensor fails, then sooner or later it will enter safe mode.",
      "gold": "<<Vehicle>>G (sensor_fault -> F safe_mode)",
      "prediction": "<<Vehicle>>G (sensor_fault -> F safe_mode)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robot number 3 does not have a strategy to guarantee position 1 holds globally.",
      "gold": "!<<Robot3>> G pos1",
      "prediction": "<<Robot3>> G pos1",
      "correct": "no",
      "reasoning": "The input states Robot3 does NOT have a strategy to guarantee that pos1 holds globally, which is expressed by negating the strategic modality: !<<Robot3>> G pos1. The prediction omits this negation and instead asserts Robot3 can guarantee it, reversing the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The industrial system can guarantee that sooner or later production will be completed.",
      "gold": "<<IndustrySystem>>F production_done",
      "prediction": "<<IndustrySystem>>F production_completed",
      "correct": "yes",
      "reasoning": "Same coalition (industrial system) and same eventuality operator F; 'production_completed' is a clear synonym of 'production_done' from the sentence.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 has a strategy to always avoid position 2 or eventually reach position 3.",
      "gold": "<<Robot1>> (G !pos2 || F pos3)",
      "prediction": "<<Robot1>> G !pos2 || F pos3",
      "correct": "no",
      "reasoning": "Missing parentheses change the scope of the coalition/temporal operators: the prediction parses as (<<Robot1>> G !pos2) || (F pos3), where reaching pos3 is no longer under Robot1's strategic control. The gold requires <<Robot1>> (G !pos2 || F pos3).",
      "decision_method": "llm"
    },
    {
      "input": "I conclude therefore that, fortune being changeful and mankind steadfast in their ways, so long as the two are in agreement men are successful, but unsuccessful when they fall out. For my part I consider that it is better to be adventurous than cautious, because fortune is a woman, and if you wish to keep her under it is necessary to beat and ill-use her; and it is seen that she allows herself to be mastered by the adventurous rather than by those who go to work more coldly.",
      "gold": " <<Men>>(G(adventurous <-> (match_fortune && success))",
      "prediction": "<<I>>(fortune_changeful && mankind_steadfast -> success) && <<I>>(adventurous -> true) && <<I>>(cautious -> false)",
      "correct": "no",
      "reasoning": "Gold attributes to coalition <<Men>> the global equivalence between being adventurous and (match_fortune && success). The prediction changes the coalition to <<I>>, drops the global G and the biconditional, and instead asserts unrelated implications and tautological/contradictory clauses (adventurous -> true, cautious -> false). This is not semantically equivalent.",
      "decision_method": "llm"
    },
    {
      "input": "The industrial system can guarantee that if a machine overheats, then at the next step it will shut down.",
      "gold": "<<IndustrySystem>>G (overheating -> X shutdown)",
      "prediction": "<<IndustrySystem>>G (overheating -> X shutdown)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The vehicle can guarantee that it will keep searching for parking until it finds a free spot.",
      "gold": "<<Vehicle>>(searching_parking U parking_found)",
      "prediction": "<<Vehicle>>(searching_for_parking U found_spot)",
      "correct": "yes",
      "reasoning": "Same coalition (Vehicle) and same until structure. The predicates are clear paraphrases: searching_for_parking matches searching_parking, and found_spot matches parking_found/free spot found.",
      "decision_method": "llm"
    },
    {
      "input": "The rover can guarantee that it will never enter a high-risk area.",
      "gold": "<<Rover>>G !in_high_risk_area",
      "prediction": "<<Rover>>G !in_high_risk_area",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The medical system can guarantee that if the heart rate is abnormal, then at the next step it will send an alarm.",
      "gold": "<<MedicalSystem>>G (heart_rate_abnormal -> X alarm_sent)",
      "prediction": "<<MedicalSystem>>G (heart_rate_abnormal -> X alarm_sent)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The logistics system can guarantee that if a delay is detected, then at the next step it will notify the customer.",
      "gold": "<<LogisticsSystem>>G (delay_detected -> X customer_notified)",
      "prediction": "<<LogisticsSystem>>G (delay_detected -> X customer_notified)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The recommender system can guarantee that sooner or later it will suggest relevant content.",
      "gold": "<<Recommender>>F relevant_content",
      "prediction": "<<Recommender>>F relevant_content_suggested",
      "correct": "no",
      "reasoning": "The gold formula requires that eventually the proposition 'relevant_content' holds, while the prediction requires that eventually 'relevant_content_suggested' holds. These are different atomic propositions: the input explicitly refers to the act of suggesting relevant content, so changing the predicate changes the expressed property unless treated as an alias, which is not justified here given the gold.",
      "decision_method": "llm"
    },
    {
      "input": "The smart city system can guarantee that sooner or later traffic will flow smoothly.",
      "gold": "<<CitySystem>>F traffic_flowing",
      "prediction": "<<CitySystem>>F traffic_smooth",
      "correct": "yes",
      "reasoning": "Same coalition (CitySystem) and same temporal operator F expressing eventuality. The predicate traffic_smooth is a clear paraphrase of 'traffic will flow smoothly' / traffic_flowing.",
      "decision_method": "llm"
    },
    {
      "input": "The financial system can guarantee that if fraud is detected, then at the next step it will block the account.",
      "gold": "<<FinanceSystem>>G (fraud_detected -> X account_blocked)",
      "prediction": "<<FinanceSystem>>G (fraud_detected -> X blocked)",
      "correct": "yes",
      "reasoning": "Same coalition (FinanceSystem) and same temporal structure G(fraud_detected -> X ...). Predicate 'blocked' is a clear alias of 'account_blocked' in context.",
      "decision_method": "llm"
    },
    {
      "input": "The coalition of robots 2 and 3 has a strategy to ensure that eventually either attack or defend holds and not retreat.",
      "gold": "<<Robot2, Robot3>> F ((attack || defend) && !retreat)",
      "prediction": "<<Robot2, Robot3>> F (attack || defend && !retreat)",
      "correct": "no",
      "reasoning": "Gold requires eventually ((attack || defend) && !retreat), i.e., not retreat must hold together with either attack or defend. Prediction parses as (attack || (defend && !retreat)) due to && binding tighter than ||, which allows attack even if retreat holds. This changes the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The collaborative robot can guarantee that it will never start picking if the grip is not stable.",
      "gold": "<<Cobot>>G (!grip_stable -> G !pick_started)",
      "prediction": "<<Cobot>>G (grip_stable -> G !picking_started)",
      "correct": "no",
      "reasoning": "The condition is inverted: gold requires that when grip_stable is false, picking never starts (!grip_stable -> G !pick_started). Prediction instead constrains behavior when grip_stable is true (grip_stable -> G !picking_started), which is a different and generally stronger/incorrect property. Predicate name difference (pick_started vs picking_started) is acceptable, but the polarity of the antecedent is not.",
      "decision_method": "llm"
    },
    {
      "input": "The rover and the base together can guarantee that sooner or later the sample will be transmitted.",
      "gold": "<<Rover,Base>>F sample_transmitted",
      "prediction": "<<Rover,Base>>F sample_transmitted",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robot number 3 does not have a strategy to ensure next that position 2 and position 3 both hold.",
      "gold": "!<<Robot3>> X (pos2 && pos3)",
      "prediction": "<<Robot3>> X (pos2 && pos3)",
      "correct": "no",
      "reasoning": "The input and gold state that Robot3 does NOT have a strategy to ensure in the next step that both pos2 and pos3 hold: !<<Robot3>> X(pos2 && pos3). The prediction omits the outer negation and instead asserts that Robot3 CAN ensure it, which is the opposite meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The medical system can guarantee that it will keep monitoring the patient until the patient is discharged.",
      "gold": "<<MedicalSystem>>(monitoring U discharged)",
      "prediction": "<<MedicalSystem>>(monitoring U discharge)",
      "correct": "no",
      "reasoning": "The gold requires monitoring until the proposition 'discharged' holds. The prediction uses a different atomic proposition 'discharge', which is not clearly an alias of 'discharged' and could denote a different event/state, so the meaning may change.",
      "decision_method": "llm"
    },
    {
      "input": "The robot and the human together can guarantee that sooner or later the part will be assembled.",
      "gold": "<<Cobot,Human>>F assembled",
      "prediction": "<<Robot,Human>>F part_assembled",
      "correct": "yes",
      "reasoning": "Coalition matches the intent (robot/cobot with human together), and the temporal operator F captures 'sooner or later'. Predicate 'assembled' vs 'part_assembled' is a clear alias from the sentence.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 has a strategy to guarantee that eventually it will reach position 1 and not position 2.",
      "gold": "<<Robot1>> F pos1 && !pos2",
      "prediction": "<<Robot1>> F (pos1 && !pos2)",
      "correct": "no",
      "reasoning": "Gold parses as (<<Robot1>> F pos1) && !pos2, requiring pos2 to be false immediately (and globally unconstrained), whereas the prediction is <<Robot1>> F (pos1 && !pos2), requiring that at some future state both pos1 holds and pos2 is false. Different scoping/meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The mobile robot can guarantee that if it receives a new goal, then sooner or later it will reach that goal.",
      "gold": "<<Robot>>G (new_goal -> F at_goal)",
      "prediction": "<<Robot>>G (new_goal -> F at_goal)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "A robot may not injure a human being or, through inaction, allow a human being to come to harm.",
      "gold": "<<Robot>>G !injure && !allow_harm",
      "prediction": "<<Robot>>G (!hurt_human && !hurt_through_inaction)",
      "correct": "no",
      "reasoning": "Gold requires globally both !injure and !allow_harm (allowing harm through inaction). Prediction uses different atomic propositions: !hurt_human is a plausible alias for !injure, but !hurt_through_inaction is not the same as !allow_harm (it forbids the robot itself harming via inaction rather than forbidding allowing a human to come to harm). Thus the meaning is changed.",
      "decision_method": "llm"
    },
    {
      "input": "The network system can guarantee that critical packet loss will never occur.",
      "gold": "<<Network>>G !critical_packet_loss",
      "prediction": "<<Network>>G !critical_packet_loss",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "Robots number 2 and number 3 have a strategy to ensure that either always position 1 holds or eventually position 2 holds.",
      "gold": "<<Robot2, Robot3>> (G pos1 || F pos2)",
      "prediction": "<<Robot2, Robot3>> (G pos1 || F pos2)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "If we do not wish to fight, we can prevent the enemy from engaging us even though the lines of our encampment be merely traced out on the ground. All we need do is to throw something odd and unaccountable in his way.",
      "gold": "weak_defense  -> <<We>> G !engaged",
      "prediction": "!fighting -> enemy_engaged U camp_traced",
      "correct": "no",
      "reasoning": "Prediction does not match the gold ATL meaning. Gold states an implication from weak_defense to an ability of coalition <<We>> to ensure globally that engagement never happens (G !engaged). The prediction has no coalition modality, changes the antecedent to !fighting, uses an until (U) instead of a global safety property, and flips/changes the engagement proposition (enemy_engaged vs !engaged) with different termination condition (camp_traced). These are semantic mismatches in agent set, temporal operator, and propositions.",
      "decision_method": "llm"
    },
    {
      "input": "The robotic arm can guarantee that it will keep aligning until the object is aligned.",
      "gold": "<<Arm>>(aligning U object_aligned)",
      "prediction": "<<Arm>>(aligning U object_aligned)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robotic arm can guarantee that if it detects a collision, then at the next step it will stop.",
      "gold": "<<Arm>>G (collision_detected -> X stopped)",
      "prediction": "<<Arm>>G (collision -> X stopped)",
      "correct": "yes",
      "reasoning": "Same coalition (Arm) and same temporal structure G( -> X ). The predicate 'collision' is a clear alias of 'collision_detected' from the sentence, and 'stopped' matches 'will stop'.",
      "decision_method": "llm"
    },
    {
      "input": "The drone can guarantee that sooner or later it will land safely.",
      "gold": "<<Drone>>F safe_landed",
      "prediction": "<<Drone>>F landing_done",
      "correct": "no",
      "reasoning": "The gold requires eventually landing safely (safe_landed). The prediction uses a different proposition (landing_done) that does not include the safety condition, so it weakens/changes the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The machine can guarantee that every time the gate opens, it will close again at the next step.",
      "gold": "<<Machine>>G (gate_open -> X !gate_open)",
      "prediction": "<<Machine>>G (gate_open -> X gate_closed)",
      "correct": "no",
      "reasoning": "The gold requires that in the next step the gate is not open (X !gate_open). The prediction instead requires a separate proposition gate_closed (X gate_closed). Unless gate_closed is explicitly defined as equivalent to !gate_open, this changes the meaning and is not semantically guaranteed to match.",
      "decision_method": "llm"
    },
    {
      "input": "The machine can guarantee that if a card or cash is inserted, then sooner or later the payment will be completed.",
      "gold": "<<Machine>>G ((card_inserted || cash_inserted) -> F paid)",
      "prediction": "<<Machine>>G (card_inserted || cash_inserted -> F payment_completed)",
      "correct": "yes",
      "reasoning": "Same coalition (Machine) and same temporal structure: globally, if (card_inserted OR cash_inserted) then eventually payment is completed. Predicate 'payment_completed' matches 'paid' from the gold as a clear alias.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 3 does not have a strategy to ensure that position 2 holds until position 5 holds.",
      "gold": "!<<Robot3>> (pos2 U pos5)",
      "prediction": "<<Robot3>> (pos2 U pos5)",
      "correct": "no",
      "reasoning": "The input and gold state that Robot3 does NOT have a strategy to ensure (pos2 U pos5), i.e., negated strategic modality. The prediction omits the negation and asserts Robot3 does have such a strategy, reversing the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The drone and the base together can guarantee that sooner or later the mission will be completed.",
      "gold": "<<Drone,Base>>F mission_completed",
      "prediction": "<<Drone,Base>>F mission_completed",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The rover can guarantee that if the temperature is too high, then at the next step it will activate cooling.",
      "gold": "<<Rover>>G (temp_high -> X cooling_on)",
      "prediction": "<<Rover>>G (temp_over_limit -> X cooling_on)",
      "correct": "yes",
      "reasoning": "Same coalition (Rover) and same temporal structure G( condition -> X action ). The predicate temp_over_limit is a clear alias of temp_high ('temperature is too high'), and cooling_on matches activating cooling.",
      "decision_method": "llm"
    },
    {
      "input": "The rover can guarantee that if communication with the base is lost, then sooner or later it will activate the backup antenna.",
      "gold": "<<Rover>>G (comm_lost -> F backup_antenna_on)",
      "prediction": "<<Rover>>G (comm_lost -> F backup_antenna_on)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The machine can guarantee that at the next step the ticket will be validated.",
      "gold": "<<Machine>>X ticket_validated",
      "prediction": "<<Machine>>X ticket_validated",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The automated warehouse can guarantee that it will never pick the wrong item.",
      "gold": "<<Warehouse>>G !wrong_item_picked",
      "prediction": "<<Warehouse>>G !wrong_pick",
      "correct": "yes",
      "reasoning": "Same coalition (automated warehouse) and same temporal requirement (globally never). Predicate 'wrong_pick' is a clear alias of 'wrong_item_picked' from the sentence.",
      "decision_method": "llm"
    },
    {
      "input": "The system and the supervisor together can guarantee that sooner or later the system will be stabilized.",
      "gold": "<<ControlSystem,Supervisor>>F stabilized",
      "prediction": "<<System, Supervisor>>F stabilization_done",
      "correct": "yes",
      "reasoning": "Same coalition (system + supervisor) and same temporal operator F expressing eventuality. Predicate name is a clear alias of 'system will be stabilized'.",
      "decision_method": "llm"
    }
  ]
}