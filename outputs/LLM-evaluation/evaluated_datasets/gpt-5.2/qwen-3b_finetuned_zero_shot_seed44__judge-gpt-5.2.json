{
  "run_id": "qwen-3b_finetuned_zero_shot_seed44",
  "git_commit": "b8e31e7",
  "dataset_path": "./data/dataset.json",
  "total_samples": 61,
  "successful_predictions": 61,
  "failed_predictions": 0,
  "model": "Qwen/Qwen2.5-3B-Instruct",
  "model_short": "qwen-3b",
  "condition": "finetuned_zero_shot",
  "seed": 44,
  "finetuned": true,
  "few_shot": false,
  "num_epochs": 10,
  "learning_rate": 0.0002,
  "batch_size": 10,
  "num_few_shot": 0,
  "price_input_per_1k": null,
  "price_output_per_1k": null,
  "gpu_hour_usd": null,
  "price_input_per_token": null,
  "price_output_per_token": null,
  "latency_mean_ms": 450.14,
  "latency_min_ms": 233.35,
  "latency_max_ms": 2227.41,
  "latency_total_ms": 27458.52,
  "latency_p50_ms": 428.94,
  "latency_p95_ms": 614.62,
  "latency_p99_ms": 1487.73,
  "timestamp_start": "2026-01-27T18:16:22Z",
  "timestamp_end": "2026-01-27T18:36:21Z",
  "duration_seconds": 1198.91,
  "metrics": {
    "n_examples": 61,
    "exact_match": 0.3442622950819672,
    "total_tokens_input": 9446,
    "total_tokens_output": 823,
    "total_tokens": 10269
  },
  "judge_model": "gpt-5.2",
  "source_file": "qwen-3b_finetuned_zero_shot_seed44.json",
  "detailed_results": [
    {
      "input": "The drone swarm can guarantee that sooner or later the area will be fully explored.",
      "gold": "<<Swarm>>F area_explored",
      "prediction": "<<Swarm>>F area_explored",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robotic arm can guarantee that if the target position changes, then at the next step it will start replanning.",
      "gold": "<<Arm>>G (target_changed -> X replanning)",
      "prediction": "<<Arm>>G (target_changed -> X replanning_started)",
      "correct": "no",
      "reasoning": "The gold requires that in the next step the system is in state replanning, while the prediction requires replanning_started. These are not guaranteed to be equivalent (starting replanning vs being replanning), so the predicate change can alter the property.",
      "decision_method": "llm"
    },
    {
      "input": "The logistics system can guarantee that sooner or later the delivery will be completed.",
      "gold": "<<LogisticsSystem>>F delivery_done",
      "prediction": "<<LogisticsSystem>>F delivery_done",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "Robots number 1 and number 2 have a strategy to guarantee that either in the next step attack holds or eventually defend holds.",
      "gold": "<<Robot1, Robot2>> (X attack || F defend)",
      "prediction": "<<Robot1, Robot2>> (X attack || F defend)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robotic arm can guarantee that it will keep moving toward the target until it reaches it.",
      "gold": "<<Arm>>(moving_to_target U at_target)",
      "prediction": "<<Arm>>(moving_target U at_target)",
      "correct": "no",
      "reasoning": "The gold requires the arm to keep satisfying proposition moving_to_target until at_target holds. The prediction uses a different atomic proposition moving_target, which is not a clear alias and changes the stated condition.",
      "decision_method": "llm"
    },
    {
      "input": "The management system can guarantee that it will never reject a valid request.",
      "gold": "<<ManagementSystem>>G !valid_request_rejected",
      "prediction": "<<ManagementSystem>>G !request_rejected",
      "correct": "no",
      "reasoning": "Gold forbids rejecting a request specifically when it is valid (!valid_request_rejected). Prediction forbids rejecting any request at all (!request_rejected), which is strictly stronger and changes the meaning by dropping the validity condition.",
      "decision_method": "llm"
    },
    {
      "input": "The satellite can guarantee that if the battery is low, then at the next step it will enable power-saving mode.",
      "gold": "<<Satellite>>G (battery_low -> X power_save_on)",
      "prediction": "<<Satellite>>G (battery_low -> X power_saving_mode)",
      "correct": "yes",
      "reasoning": "Same coalition (Satellite) and same temporal structure G(battery_low -> X ...). The predicate power_saving_mode is a clear alias of power_save_on from the sentence.",
      "decision_method": "llm"
    },
    {
      "input": "Robots number 1 and number 2 have a joint strategy to always avoid position 3.",
      "gold": "<<Robot1, Robot2>> G !pos3",
      "prediction": "<<Robot1, Robot2>> G !pos3",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The financial system can guarantee that it will keep verifying until the payment is valid.",
      "gold": "<<FinanceSystem>>(verifying U payment_valid)",
      "prediction": "<<FinancialSystem>>(verifying U payment_valid)",
      "correct": "yes",
      "reasoning": "Coalition refers to the same financial system, and the formula preserves the until structure: verifying holds until payment_valid becomes true.",
      "decision_method": "llm"
    },
    {
      "input": "The management system and the manager together can guarantee that sooner or later the goal will be reached.",
      "gold": "<<ManagementSystem,Manager>>F goal_reached",
      "prediction": "<<ManagementSystem,Manager>>F goal_reached",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "Robots number 1 and number 2 together have a strategy to ensure next that if defend then retreat.",
      "gold": "<<Robot1, Robot2>> X (pos2 -> pos3)",
      "prediction": "<<Robot1, Robot2>> X (defend -> retreat)",
      "correct": "no",
      "reasoning": "Although the coalition and X operator match, the gold formula uses different atomic propositions (pos2 -> pos3) than the prediction (defend -> retreat). This changes the expressed property unless those predicates are known aliases, which is not indicated.",
      "decision_method": "llm"
    },
    {
      "input": "The robotic arm can guarantee that if the object is fragile, then it will never exceed a maximum force.",
      "gold": "<<Arm>>G (fragile_object -> G !force_over_limit)",
      "prediction": "<<Arm>>G (object_fragile -> G !force_over_max)",
      "correct": "yes",
      "reasoning": "Same coalition (Arm) and same temporal structure: globally, if the object is fragile then globally the force is not over the limit. Predicate names are clear paraphrases (fragile_object/object_fragile, force_over_limit/force_over_max) with no polarity or operator change.",
      "decision_method": "llm"
    },
    {
      "input": "The financial system can guarantee that sooner or later the transaction will be completed.",
      "gold": "<<FinanceSystem>>F transaction_completed",
      "prediction": "<<FinancialSystem>>F transaction_done",
      "correct": "yes",
      "reasoning": "Coalition refers to the same actor (financial system) and the temporal operator F matches 'sooner or later'. Predicate 'transaction_done' is a clear synonym of 'transaction_completed' in this context.",
      "decision_method": "llm"
    },
    {
      "input": "The mobile robot can guarantee that if the map is invalid, then at the next step it will enter exploration mode.",
      "gold": "<<Robot>>G (map_invalid -> X exploration_mode)",
      "prediction": "<<Robot>>G (map_invalid -> X exploration_mode)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The rover can guarantee that if it detects a sandstorm, then at the next step it will enter shelter mode.",
      "gold": "<<Rover>>G (sandstorm_detected -> X shelter_mode)",
      "prediction": "<<Rover>>G (sandstorm -> X shelter_mode)",
      "correct": "no",
      "reasoning": "The gold condition is triggered by the proposition sandstorm_detected, while the prediction uses sandstorm. This changes the meaning (detecting a sandstorm vs a sandstorm occurring), so the formulas are not semantically equivalent.",
      "decision_method": "llm"
    },
    {
      "input": "The robotic arm can guarantee that if the object is aligned, then at the next step it will close the gripper.",
      "gold": "<<Arm>>G (object_aligned -> X gripper_closed)",
      "prediction": "<<Arm>>G (object_aligned -> X gripper_closed)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The drone and the wind together can guarantee that sooner or later the drone will move away from the waypoint.",
      "gold": "<<Drone,Wind>>F !at_waypoint",
      "prediction": "<<Drone,Wind>>F drone_moves_away_from_waypoint",
      "correct": "no",
      "reasoning": "Gold requires that eventually the drone is not at the waypoint (F !at_waypoint). The prediction instead requires eventually a specific action/event predicate (F drone_moves_away_from_waypoint), which is not semantically equivalent: the drone could become not-at-waypoint without that predicate holding, or the predicate could hold without ensuring !at_waypoint. Thus the expressed property changes.",
      "decision_method": "llm"
    },
    {
      "input": "The drone can guarantee that sooner or later it will reach the destination waypoint.",
      "gold": "<<Drone>>F at_waypoint",
      "prediction": "<<Drone>>F at_destination",
      "correct": "no",
      "reasoning": "The temporal operator and coalition match, but the atomic proposition differs: gold requires eventually being at the (destination) waypoint (at_waypoint), while the prediction requires eventually being at_destination. These are not clear aliases, so the expressed property changes.",
      "decision_method": "llm"
    },
    {
      "input": "It is not the case that robots 1, 2 and 3 have a strategy to enforce globally position 1.",
      "gold": "!<<Robot1, Robot2, Robot3>> G pos1",
      "prediction": "<<Robot1, Robot2, Robot3>> G pos1",
      "correct": "no",
      "reasoning": "The input and gold formula negate the coalition ability: it is NOT the case that <<Robot1,Robot2,Robot3>> can enforce G pos1. The prediction omits the outer negation, asserting they do have such a strategy, which is the opposite meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The world’s stable now. People are happy; they get what they want, and they never want what they can’t get. They’re well off; they’re safe; they’re never ill; they’re not afraid of death; they’re blissfully ignorant of passion and old age; they’re plagued with no mothers or fathers; they’ve got no wives, or children, or lovers to feel strongly about; they’re so conditioned that they practically can’t help behaving as they ought to behave.",
      "gold": "<<World>>G stable",
      "prediction": "<<World>>G (people_happy && people_get_what_they_want && !people_want_what_they_cannot_get && people_are_safe && !people_are_ill && !people_fear_death && !people_feel_strongly_about_age && !people_have_emotions && !people_have_family)",
      "correct": "no",
      "reasoning": "Gold states only that the World can guarantee that stability holds globally (<<World>>G stable). The prediction instead asserts a global conjunction of many additional properties (happiness, safety, no illness, etc.) and does not include stable. This changes the expressed property substantially.",
      "decision_method": "llm"
    },
    {
      "input": "If we wish to fight, the enemy can be forced to an engagement even though he be sheltered behind a high rampart and a deep ditch. All we need do is attack some other place that he will be obliged to relieve.",
      "gold": "<<We>> sheltered_high_rampart && sheltered_deep_ditch -> attack_other_place",
      "prediction": "<<We>> attack some other place that he will be obliged to relieve.",
      "correct": "no",
      "reasoning": "Prediction is not a valid ATL formula and does not match the gold structure. The gold expresses an implication with antecedent (sheltered_high_rampart && sheltered_deep_ditch) and consequent attack_other_place under coalition <<We>>. The prediction is just an English fragment, missing the implication, missing the shelter conditions, and not syntactically ATL.",
      "decision_method": "llm"
    },
    {
      "input": "The game system can guarantee that a critical bug will never occur.",
      "gold": "<<GameSystem>>G !critical_bug",
      "prediction": "<<GameSystem>>G !critical_bug",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robot number 1 has a strategy to guarantee that if position 1 holds now then position 4 will eventually hold.",
      "gold": "<<Robot1>> (pos1 -> F pos4)",
      "prediction": "<<Robot1>> G (pos1 -> F pos4)",
      "correct": "no",
      "reasoning": "Gold states a one-time condition from the current state: if pos1 holds now, then pos4 will eventually hold. The prediction adds a global G, requiring this implication to hold at all future states, which is strictly stronger and changes the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The collaborative robot can guarantee that sooner or later it will resume work after a pause.",
      "gold": "<<Cobot>>F work_resumed",
      "prediction": "<<Cobot>>G (paused -> XF)",
      "correct": "no",
      "reasoning": "Gold states the cobot can ensure that eventually work_resumed holds (<<Cobot>>F work_resumed). The prediction instead uses a global implication with an ill-formed/incorrect temporal part (G (paused -> XF)) and does not assert eventual work_resumed; it changes the temporal structure and meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 3 does not have a strategy to ensure that in the next state either position 1 or position 2 are valid.",
      "gold": "!<<Robot3>> X (pos1 || pos2)",
      "prediction": "<<Robot3>> X (pos1 || pos2)",
      "correct": "no",
      "reasoning": "The input and gold state that Robot3 does NOT have a strategy to ensure the next-state disjunction, i.e., negated ability !<<Robot3>>X(...). The prediction omits the negation and asserts Robot3 CAN ensure it, which is the opposite meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The automated warehouse can guarantee that it will never pick the wrong item.",
      "gold": "<<Warehouse>>G !wrong_item_picked",
      "prediction": "<<Warehouse>>G !wrong_item",
      "correct": "no",
      "reasoning": "Although the coalition and the global negation structure match, the atomic proposition differs: gold forbids the event/state 'wrong_item_picked', while the prediction forbids 'wrong_item' (which could mean the wrong item exists/is present). This changes the expressed property.",
      "decision_method": "llm"
    },
    {
      "input": "The smart grid can guarantee that sooner or later the load will be balanced.",
      "gold": "<<Grid>>F load_balanced",
      "prediction": "<<Grid>>F load_balanced",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robot number 1 has a strategy to guarantee globally that position 2 implies eventually position 3.",
      "gold": "<<Robot1>> G (pos2 -> F pos3)",
      "prediction": "<<Robot1>> (pos2 -> F pos3)",
      "correct": "no",
      "reasoning": "Gold requires the guarantee to hold globally (G): at all times, if pos2 holds then eventually pos3. The prediction omits the outer G, so it only requires the implication from the initial state, which is weaker.",
      "decision_method": "llm"
    },
    {
      "input": "The drone can guarantee that sooner or later it will land safely.",
      "gold": "<<Drone>>F safe_landed",
      "prediction": "<<Drone>>F safe_land",
      "correct": "yes",
      "reasoning": "Same coalition (Drone) and same temporal operator F (eventually). Predicate safe_land is a clear alias of safe_landed from the sentence, preserving meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The medical system can guarantee that sooner or later the patient will receive the treatment.",
      "gold": "<<MedicalSystem>>F treatment_given",
      "prediction": "<<MedicalSystem>>F treatment_done",
      "correct": "yes",
      "reasoning": "Same coalition (MedicalSystem) and same temporal operator F expressing eventuality; 'treatment_done' is a clear alias of 'treatment_given' in this context.",
      "decision_method": "llm"
    },
    {
      "input": "The system and the user together can guarantee that sooner or later the refund will be credited.",
      "gold": "<<FinanceSystem,User>>F refund_credited",
      "prediction": "<<User,RefundSystem>>F refund_credited",
      "correct": "no",
      "reasoning": "Coalition is different: gold requires <<FinanceSystem,User>> but prediction uses <<User,RefundSystem>>. Changing the agent set changes who has the ability to ensure eventual refund_credited.",
      "decision_method": "llm"
    },
    {
      "input": "He will win whose army is animated by the same spirit throughout all its ranks.",
      "gold": "same_spirit_in_ranks  ->  <<Army>>F achieve_victory",
      "prediction": "<<Army>>(G strength)",
      "correct": "no",
      "reasoning": "Gold states an implication: if the army has the same spirit in all ranks, then the Army coalition can eventually achieve victory (<<Army>>F achieve_victory). Prediction instead asserts the Army can guarantee strength always (<<Army>>G strength), which changes the condition (drops the antecedent), the temporal goal (F vs G), and the proposition (achieve_victory vs strength).",
      "decision_method": "llm"
    },
    {
      "input": "Robots number 1 and number 2 have a strategy to ensure that position 2 holds until either position 3 or position 4 holds.",
      "gold": "<<Robot1, Robot2>> (pos2 U (pos3 || pos4))",
      "prediction": "<<Robot1, Robot2>> ((pos2 U (pos3 || pos4))",
      "correct": "no",
      "reasoning": "Prediction is syntactically malformed due to an unmatched parenthesis, so it is not a valid ATL formula. Semantically it appears intended to match the gold, but as written it cannot be accepted as correct.",
      "decision_method": "llm"
    },
    {
      "input": "The education system can guarantee that it will keep evaluating until competence is reached.",
      "gold": "<<EduSystem>>(evaluating U competence_reached)",
      "prediction": "<<EduSystem>>(evaluating U competence_reached)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The emergency system can guarantee that sooner or later rescue teams will arrive.",
      "gold": "<<EmergencySystem>>F rescue_arrived",
      "prediction": "<<EmergencySystem>>F rescue_teams_arrived",
      "correct": "yes",
      "reasoning": "Same coalition (EmergencySystem) and same eventuality operator F; predicate 'rescue_teams_arrived' matches the stated meaning that rescue teams will arrive.",
      "decision_method": "llm"
    },
    {
      "input": "The robot and the human together can guarantee that sooner or later the part will be assembled.",
      "gold": "<<Cobot,Human>>F assembled",
      "prediction": "<<Robot,Human>>F part_assembled",
      "correct": "yes",
      "reasoning": "Coalition matches the robot+human team (Cobot vs Robot is an alias), temporal operator F captures 'sooner or later', and 'assembled' vs 'part_assembled' is a consistent predicate refinement from the sentence.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 has a strategy to ensure that always eventually position 2 or always eventually position 3.",
      "gold": "<<Robot1>> (G F pos2 || G F pos3)",
      "prediction": "<<Robot1>> (G F pos2 || G F pos3)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The coalition of robots 1 and 3 has a strategy to ensure that in the next step either position 2 or position 4 holds.",
      "gold": "<<Robot1, Robot3>> X (pos2 || pos4)",
      "prediction": "<<Robot1, Robot3>> X (pos2 || pos4)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The rover can guarantee that if the slope is too steep, then it will never move forward in that direction.",
      "gold": "<<Rover>>G (slope_too_high -> G !moving_forward)",
      "prediction": "<<Rover>>G (steep_slope -> G !forward_move)",
      "correct": "yes",
      "reasoning": "Same coalition (Rover) and same temporal structure: globally, if the slope is too steep then globally it will not move forward. Predicate names are clear aliases (slope_too_high≈steep_slope, moving_forward≈forward_move) with no polarity change.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 does not have a strategy to guarantee that always eventually position 5 holds.",
      "gold": "!<<Robot1>> G F pos5",
      "prediction": "<<Robot1>> G F pos5",
      "correct": "no",
      "reasoning": "The input states Robot1 does NOT have a strategy to guarantee the property, which is captured by negating the strategic modality: !<<Robot1>> G F pos5. The prediction omits this negation and instead asserts Robot1 can guarantee G F pos5, reversing the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The machine can guarantee that if the payment has been completed, then at the next step it will print the ticket.",
      "gold": "<<Machine>>G (paid -> X ticket_printed)",
      "prediction": "<<Machine>>G (payment_completed -> X ticket_printed)",
      "correct": "yes",
      "reasoning": "Same coalition (Machine) and same temporal structure G( -> X ). Predicate 'payment_completed' is a clear alias of 'paid' from the sentence, so the meaning is preserved.",
      "decision_method": "llm"
    },
    {
      "input": "The recommender system can guarantee that sooner or later it will suggest relevant content.",
      "gold": "<<Recommender>>F relevant_content",
      "prediction": "<<Recommender>>F relevant_content",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robot number 2 has a strategy to ensure always either position 1 or position 3 holds.",
      "gold": "<<Robot2>> G (pos1 || pos3)",
      "prediction": "<<Robot2>> G (pos1 || pos3)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "None of the robots number 1, 2, or 3 has a strategy to ensure that position 1 is globally avoided.",
      "gold": "!<<Robot1>> G !pos1 && !<<Robot2>> G !pos1 && !<<Robot3>> G !pos1",
      "prediction": "<<Robot1>> G !pos1 && !<<Robot2>> G !pos1 && !<<Robot3>> G !pos1",
      "correct": "no",
      "reasoning": "The input says none of Robot1/2/3 has a strategy to ensure globally avoiding pos1, i.e., each ability formula must be negated: !<<Roboti>> G !pos1. The prediction omits the negation for Robot1 (uses <<Robot1>> G !pos1), asserting Robot1 can ensure avoidance, which contradicts the statement.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 2 does not have a strategy to ensure that position 3 will hold until position 1 holds.",
      "gold": "!<<Robot2>> (pos3 U pos1)",
      "prediction": "<<Robot2>> (pos3 U pos1)",
      "correct": "no",
      "reasoning": "The input and gold state that Robot2 does NOT have a strategy to ensure (pos3 U pos1), i.e., negated ability. The prediction omits the leading negation and asserts Robot2 does have such a strategy, reversing the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The rover can guarantee that when it is ready to sample, at the next step it will start sampling.",
      "gold": "<<Rover>>G (ready_to_sample -> X sampling_started)",
      "prediction": "<<Rover>>G (ready_to_sample -> X sampling)",
      "correct": "no",
      "reasoning": "The gold requires that the next state satisfies the specific proposition sampling_started. The prediction uses a different atomic proposition sampling, which is not a clear alias of 'start sampling' and could mean 'is sampling' rather than 'has started sampling', changing the expressed property.",
      "decision_method": "llm"
    },
    {
      "input": "The system can guarantee that it will keep monitoring until the observation window ends.",
      "gold": "<<System>>(monitoring U window_closed)",
      "prediction": "<<System>>(monitoring U observation_window_ends)",
      "correct": "yes",
      "reasoning": "Same coalition (System) and same until structure (monitoring U ...). The predicate 'observation_window_ends' is a clear alias of 'window_closed' from the sentence.",
      "decision_method": "llm"
    },
    {
      "input": "The drone can guarantee that it will keep holding altitude until it receives a descend command.",
      "gold": "<<Drone>>(holding_altitude U descend_command)",
      "prediction": "<<Drone>>(holding_altitude U descend_command)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The industrial system can guarantee that if a machine overheats, then at the next step it will shut down.",
      "gold": "<<IndustrySystem>>G (overheating -> X shutdown)",
      "prediction": "<<IndustrySystem>>G (machine_overheated -> X shutdown)",
      "correct": "yes",
      "reasoning": "Same coalition (industrial system) and same temporal structure G( -> X ). Predicate 'machine_overheated' is a clear alias of 'overheating' from the sentence, and shutdown is unchanged.",
      "decision_method": "llm"
    },
    {
      "input": "The robotic arm can guarantee that if it detects a collision, then at the next step it will stop.",
      "gold": "<<Arm>>G (collision_detected -> X stopped)",
      "prediction": "<<Arm>>G (collision -> X stopped)",
      "correct": "no",
      "reasoning": "Predicate mismatch: gold conditions on collision_detected (the arm detects a collision), while prediction uses collision (a collision occurs). This changes the meaning of the trigger condition.",
      "decision_method": "llm"
    },
    {
      "input": "The arm and the controller together can guarantee that sooner or later the object will be placed into the container.",
      "gold": "<<Arm,Controller>>F object_placed",
      "prediction": "<<Arm,Controller>>F object_placed",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The rover can guarantee that if communication with the base is lost, then sooner or later it will activate the backup antenna.",
      "gold": "<<Rover>>G (comm_lost -> F backup_antenna_on)",
      "prediction": "<<Rover>>G (comm_lost -> F backup_antenna_on)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The machine can guarantee that every time the gate opens, it will close again at the next step.",
      "gold": "<<Machine>>G (gate_open -> X !gate_open)",
      "prediction": "<<Machine>>G (gate_open -> X gate_closed)",
      "correct": "no",
      "reasoning": "The gold requires that in the next step the gate is not open (X !gate_open). The prediction instead requires a separate proposition gate_closed in the next step. Unless gate_closed is defined as exactly equivalent to !gate_open (not given), this changes the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The warehouse can guarantee that it will keep sorting until the exit area is clear.",
      "gold": "<<Warehouse>>(sorting U exit_clear)",
      "prediction": "<<Warehouse>>(sorting U exit_clear)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "Robots number 1 and number 3 together do not have a strategy to ensure eventually not position 2.",
      "gold": "!<<Robot1, Robot3>> F !pos2",
      "prediction": "<<Robot1, Robot3>> F !pos2",
      "correct": "no",
      "reasoning": "The input/gold states the coalition lacks a strategy: !<<Robot1, Robot3>> F !pos2. The prediction omits the leading negation and instead asserts they do have such a strategy, reversing the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 has a strategy to ensure that if position 1 ever occurs then position 2 will hold in the next step.",
      "gold": "<<Robot1>> (F pos1 -> X pos2)",
      "prediction": "<<Robot1>> (F pos1 -> X pos2)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The machine can guarantee that if an error occurs at the next step, then sooner or later the system will be recovered.",
      "gold": "<<Machine>>G (X error -> F recovered)",
      "prediction": "<<Machine>>G (error -> F recovery)",
      "correct": "no",
      "reasoning": "Gold requires the condition to be an error occurring at the next step (X error). Prediction drops the X and instead conditions on an error now, changing the temporal meaning. Also it changes the proposition from recovered to recovery, which is not guaranteed to be an alias.",
      "decision_method": "llm"
    },
    {
      "input": "The autonomous vehicle can guarantee that it will never exceed the speed limit.",
      "gold": "<<Vehicle>>G !speed_over_limit",
      "prediction": "<<Vehicle>>G !speed_over_limit",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robot number 1 has a strategy to ensure eventually reach position 4 or to always stay in position 1.",
      "gold": "<<Robot1>> (F pos4 || G pos1)",
      "prediction": "<<Robot1>> (F pos4 || G pos1)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The machine can guarantee that if a card or cash is inserted, then sooner or later the payment will be completed.",
      "gold": "<<Machine>>G ((card_inserted || cash_inserted) -> F paid)",
      "prediction": "<<Machine>>G (card_inserted || cash_inserted -> F payment_completed)",
      "correct": "yes",
      "reasoning": "Same coalition (Machine) and same temporal structure: globally, if (card_inserted OR cash_inserted) then eventually payment is completed. Predicate 'payment_completed' is a clear alias of 'paid' from the sentence.",
      "decision_method": "llm"
    },
    {
      "input": "The mobile robot can guarantee that if it is in emergency mode, then it will always remain stopped.",
      "gold": "<<Robot>>G (emergency_mode -> G stopped)",
      "prediction": "<<Robot>>G (emergency -> G stopped)",
      "correct": "no",
      "reasoning": "Predicate mismatch: gold conditions on emergency_mode, while prediction uses emergency. Without an explicit alias, this changes the meaning of when the guarantee applies; temporal/coalition structure matches but the state proposition differs.",
      "decision_method": "llm"
    }
  ]
}