{
  "run_id": "qwen-3b_finetuned_zero_shot_seed45",
  "git_commit": "b8e31e7",
  "dataset_path": "./data/dataset.json",
  "total_samples": 61,
  "successful_predictions": 61,
  "failed_predictions": 0,
  "model": "Qwen/Qwen2.5-3B-Instruct",
  "model_short": "qwen-3b",
  "condition": "finetuned_zero_shot",
  "seed": 45,
  "finetuned": true,
  "few_shot": false,
  "num_epochs": 10,
  "learning_rate": 0.0002,
  "batch_size": 10,
  "num_few_shot": 0,
  "price_input_per_1k": null,
  "price_output_per_1k": null,
  "gpu_hour_usd": null,
  "price_input_per_token": null,
  "price_output_per_token": null,
  "latency_mean_ms": 416.9,
  "latency_min_ms": 230.17,
  "latency_max_ms": 667.81,
  "latency_total_ms": 25430.84,
  "latency_p50_ms": 426.04,
  "latency_p95_ms": 588.0,
  "latency_p99_ms": 627.91,
  "timestamp_start": "2026-01-27T18:45:14Z",
  "timestamp_end": "2026-01-27T19:03:39Z",
  "duration_seconds": 1105.05,
  "metrics": {
    "n_examples": 61,
    "exact_match": 0.2459016393442623,
    "total_tokens_input": 9488,
    "total_tokens_output": 760,
    "total_tokens": 10248
  },
  "judge_model": "gpt-5.2",
  "source_file": "qwen-3b_finetuned_zero_shot_seed45.json",
  "detailed_results": [
    {
      "input": "The financial system can guarantee that an unauthorized transaction will never be executed.",
      "gold": "<<FinanceSystem>>G !unauthorized_transaction",
      "prediction": "<<FinanceSystem>>G !unauthorized_transaction",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The collaborative robot can guarantee that it will keep running the cycle until a stop is requested.",
      "gold": "<<Cobot>>(cycle_running U stop_requested)",
      "prediction": "<<Cobot>>(running_cycle U stop_requested)",
      "correct": "yes",
      "reasoning": "Same coalition (<<Cobot>>) and same until structure; 'running_cycle' is a clear alias of 'cycle_running' from the sentence.",
      "decision_method": "llm"
    },
    {
      "input": "The rover can guarantee that if communication with the base is lost, then sooner or later it will activate the backup antenna.",
      "gold": "<<Rover>>G (comm_lost -> F backup_antenna_on)",
      "prediction": "<<Rover>>G (communication_lost -> F backup_activated)",
      "correct": "yes",
      "reasoning": "Same coalition (Rover) and same temporal structure: globally, if communication is lost then eventually the backup antenna is activated. Predicate names are clear paraphrases (comm_lost ≈ communication_lost; backup_antenna_on ≈ backup_activated).",
      "decision_method": "llm"
    },
    {
      "input": "The user can guarantee that they will continue attempting payment until it is completed.",
      "gold": "<<User>>(!paid U paid)",
      "prediction": "<<User>>(attempts_payment U payment_completed)",
      "correct": "no",
      "reasoning": "Gold says the user can ensure an until where the left side is !paid (i.e., payment not completed) until paid becomes true. Prediction instead requires attempts_payment to hold until payment_completed, adding a different condition and not enforcing !paid before completion. Predicates and meaning are not equivalent.",
      "decision_method": "llm"
    },
    {
      "input": "The robotic arm can guarantee that sooner or later it will grasp the object.",
      "gold": "<<Arm>>F object_grasped",
      "prediction": "<<Arm>>F grasped",
      "correct": "yes",
      "reasoning": "Same coalition (Arm) and same temporal operator F expressing eventuality; predicate 'grasped' is a clear alias of 'object_grasped' from the sentence.",
      "decision_method": "llm"
    },
    {
      "input": "The collaborative robot can guarantee that if the human confirms, then at the next step it will start assembly.",
      "gold": "<<Cobot, Human>>G (human_confirmed -> X assembly_started)",
      "prediction": "<<Cobot>>G (human_confirmed -> X assembly_started)",
      "correct": "no",
      "reasoning": "The gold formula attributes the guarantee to the coalition <<Cobot, Human>>, while the prediction uses only <<Cobot>>. Changing the coalition changes the strategic ability being claimed, so the meaning is not preserved.",
      "decision_method": "llm"
    },
    {
      "input": "The collaborative robot can guarantee that if the grip fails, then sooner or later it will retry.",
      "gold": "<<Cobot>>G (grip_failed -> F retry_grip)",
      "prediction": "<<Cobot>>G (grip_failed -> F retry)",
      "correct": "yes",
      "reasoning": "Same coalition (<<Cobot>>), same global implication structure G(grip_failed -> F ...), and 'retry' is a clear alias of 'retry_grip' in context; temporal operator F matches 'sooner or later'.",
      "decision_method": "llm"
    },
    {
      "input": "Robots number 1 and number 2 have a strategy to ensure that position 3 holds until position 4 holds and not position 5.",
      "gold": "<<Robot1, Robot2>> ((pos3 U pos4) && !pos5)",
      "prediction": "<<Robot1, Robot2>> (pos3 U (pos4 && !pos5))",
      "correct": "no",
      "reasoning": "Gold requires both (pos3 U pos4) and !pos5 to hold (i.e., pos5 is false throughout, including after pos4). Prediction instead requires pos3 to hold until a state where both pos4 and !pos5 hold, allowing pos5 to be true before that point. This changes the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The mobile robot can guarantee that when it is near the base, at the next step it will enable docking mode.",
      "gold": "<<Robot>>G (near_base -> X docking_mode)",
      "prediction": "<<Robot>>G (near_base -> X docking_mode_on)",
      "correct": "yes",
      "reasoning": "Same coalition (Robot) and same temporal structure G(near_base -> X ...). The predicate 'docking_mode_on' is a clear alias of 'docking_mode' from the sentence, with no polarity or operator change.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 2 has a strategy to ensure that globally reach position 2.",
      "gold": "<<Robot2>> F pos2",
      "prediction": "<<Robot2>> G pos2",
      "correct": "no",
      "reasoning": "The gold formula <<Robot2>> F pos2 means Robot2 can ensure that position 2 is reached eventually. The prediction <<Robot2>> G pos2 instead means Robot2 can ensure it is always in position 2 globally, which is strictly stronger and not equivalent.",
      "decision_method": "llm"
    },
    {
      "input": "The industrial system can guarantee that it will keep calibrating until quality is acceptable.",
      "gold": "<<IndustrySystem>>(calibrating U quality_ok)",
      "prediction": "<<IndustrySystem>>(calibrating U quality_ok)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robot number 1 has a strategy to guarantee globally that position 2 implies eventually position 3.",
      "gold": "<<Robot1>> G (pos2 -> F pos3)",
      "prediction": "<<Robot1>> G (pos2 -> F pos3)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "Robots number 2 and number 3 have a strategy to ensure that always not position 4.",
      "gold": "<<Robot2, Robot3>> G !pos4",
      "prediction": "<<Robot2, Robot3>> G !pos4",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The management system can guarantee that it will never reject a valid request.",
      "gold": "<<ManagementSystem>>G !valid_request_rejected",
      "prediction": "<<ManagementSystem>>G !request_rejected",
      "correct": "no",
      "reasoning": "Gold forbids rejecting a request specifically when it is valid (!valid_request_rejected). Prediction forbids rejecting any request at all (!request_rejected), which is strictly stronger and changes the meaning by dropping the validity condition.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 has a strategy to always avoid position 2 or eventually reach position 3.",
      "gold": "<<Robot1>> (G !pos2 || F pos3)",
      "prediction": "<<Robot1>> G !pos2 || F pos3",
      "correct": "no",
      "reasoning": "The prediction lacks parentheses, so it is parsed as (<<Robot1>> G !pos2) || (F pos3), where the second disjunct is not under the coalition modality. The gold requires <<Robot1>> to have a strategy ensuring the whole disjunction (G !pos2 || F pos3). This changes the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The system and the controller together can guarantee that sooner or later consumption will be reduced.",
      "gold": "<<ClimateSystem,Controller>>F consumption_reduced",
      "prediction": "<<ControlSystem,Controller>>F consumption_reduced",
      "correct": "no",
      "reasoning": "Coalition/agent set differs: gold is <<ClimateSystem,Controller>> but prediction uses <<ControlSystem,Controller>>. This changes who has the ability, even though the temporal operator F and proposition match.",
      "decision_method": "llm"
    },
    {
      "input": "The control system can guarantee that it will never cause instability.",
      "gold": "<<ControlSystem>>G !unstable",
      "prediction": "<<ControlSystem>>G !instability",
      "correct": "no",
      "reasoning": "Although the coalition and temporal operator match (<<ControlSystem>>G), the atomic proposition differs: gold uses !unstable while prediction uses !instability. Without an explicit alias/equivalence, changing the predicate changes the property.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 has a strategy to guarantee that it will keep position 1 until move is true and while not attack.",
      "gold": "<<Robot1>> (pos1 U (move && !attack))",
      "prediction": "<<Robot1>> (pos1 U (move && W !attack))",
      "correct": "no",
      "reasoning": "Gold requires reaching a state where both move is true and attack is false: (pos1 U (move && !attack)). Prediction replaces !attack with (W !attack), which is a temporal formula, changing the target of U and allowing satisfaction without necessarily having !attack at the move point. This alters the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The robotic arm can guarantee that it will never exceed the torque limit.",
      "gold": "<<Arm>>G !torque_over_limit",
      "prediction": "<<Arm>>G !torque_over_limit",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The drone can guarantee that if it loses GPS signal, then at the next step it will switch to inertial navigation.",
      "gold": "<<Drone>>G (gps_lost -> X inertial_nav_on)",
      "prediction": "<<Drone>>G (GPS_lost -> X inertial_on)",
      "correct": "yes",
      "reasoning": "Same coalition (Drone) and same temporal structure G( -> X ). Predicate names are clear aliases: gps_lost/GPS_lost and inertial_nav_on/inertial_on both denote switching to inertial navigation.",
      "decision_method": "llm"
    },
    {
      "input": "The system and the user together can guarantee that sooner or later the refund will be credited.",
      "gold": "<<FinanceSystem,User>>F refund_credited",
      "prediction": "<<ReimbursementSystem,User>>F refunded",
      "correct": "no",
      "reasoning": "Coalition differs: gold is <<FinanceSystem,User>> but prediction uses <<ReimbursementSystem,User>>. Also the proposition changes from refund_credited to refunded, which is not a clear alias and could change meaning (credited vs merely refunded).",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 2 has a strategy to Globally reach position 1 and not position 2 and not position 3.",
      "gold": "<<Robot2>> G pos1 && pos2 && !pos3",
      "prediction": "<<Robot2>> G (pos1 && !pos2 && !pos3)",
      "correct": "no",
      "reasoning": "The prediction enforces globally (pos1 AND not pos2 AND not pos3). The gold formula is <<Robot2>> G pos1 && pos2 && !pos3, which (given standard precedence) means (<<Robot2>> G pos1) AND pos2 AND !pos3, and even if intended as G(pos1 && pos2 && !pos3) it requires pos2 to hold, not be false. Thus the polarity/requirement on pos2 differs.",
      "decision_method": "llm"
    },
    {
      "input": "The warehouse can guarantee that if a shelf is empty, then at the next step it will request restocking.",
      "gold": "<<Warehouse>>G (shelf_empty -> X restock_requested)",
      "prediction": "<<Warehouse>>G (shelf_empty -> X stocking_requested)",
      "correct": "no",
      "reasoning": "Predicate mismatch: gold requires X restock_requested, but prediction uses X stocking_requested. Unless explicitly defined as the same proposition, this changes the property being guaranteed.",
      "decision_method": "llm"
    },
    {
      "input": "The collaborative robot can guarantee that if a human enters the area, then at the next step it will reduce speed.",
      "gold": "<<Cobot>>G (human_in_area -> X speed_low)",
      "prediction": "<<Cobot>>G (human_entered_area -> X speed_low)",
      "correct": "yes",
      "reasoning": "Same coalition (<<Cobot>>), same global implication structure G(p -> X q), and the predicate human_entered_area is a clear alias of human_in_area from the sentence; consequent X speed_low matches.",
      "decision_method": "llm"
    },
    {
      "input": "The robotic arm can guarantee that it will keep moving toward the target until it reaches it.",
      "gold": "<<Arm>>(moving_to_target U at_target)",
      "prediction": "<<Arm>>(moving_toward_target U reached)",
      "correct": "yes",
      "reasoning": "Same coalition (Arm) and same until structure. Predicates are clear paraphrases: moving_toward_target matches moving_to_target, and reached corresponds to at_target (reaching the target).",
      "decision_method": "llm"
    },
    {
      "input": "The recommender system can guarantee that sooner or later it will suggest relevant content.",
      "gold": "<<Recommender>>F relevant_content",
      "prediction": "<<Recommender>>F relevant_content",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robotic arm can guarantee that if the gripper is closed, then sooner or later the object will be lifted.",
      "gold": "<<Arm>>G (gripper_closed -> F object_lifted)",
      "prediction": "<<Arm>>G (gripper_closed -> F object_lifted)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The robot number 1 has a strategy to ensure that if position 1 ever occurs then position 2 will hold in the next step.",
      "gold": "<<Robot1>> (F pos1 -> X pos2)",
      "prediction": "<<Robot1>> (F pos1 -> X pos2)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "It is not the case that robots 1, 2 and 3 have a strategy to enforce globally position 1.",
      "gold": "!<<Robot1, Robot2, Robot3>> G pos1",
      "prediction": "<<Robot1, Robot2, Robot3>> G pos1",
      "correct": "no",
      "reasoning": "The input and gold formula negate the coalition’s ability: it is NOT the case that <<Robot1,Robot2,Robot3>> can enforce G pos1. The prediction omits the outer negation, asserting they DO have such a strategy, which is the opposite meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 1 has a strategy to guarantee that eventually it reaches position 2 without ever reaching position 3.",
      "gold": "<<Robot1>> F (pos2 && G !pos3)",
      "prediction": "<<Robot1>> F (pos2 && G !pos3)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "It is not the case that robots 1 and 3 have a strategy to always eventually reach position 2.",
      "gold": "!<<Robot1, Robot3>> G F pos2",
      "prediction": "<<Robot1, Robot3>> G F pos2",
      "correct": "no",
      "reasoning": "The input and gold formula negate the coalition ability: it is NOT the case that <<Robot1,Robot3>> can ensure G F pos2. The prediction omits the leading negation, asserting the opposite property.",
      "decision_method": "llm"
    },
    {
      "input": "The management system can guarantee that if a priority changes, then at the next step it will update the schedule.",
      "gold": "<<ManagementSystem>>G (priority_changed -> X schedule_updated)",
      "prediction": "<<ManagementSystem>>G (priority_changed -> X schedule_updated)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The mobile robot can guarantee that sooner or later it will deliver the package to the drop-off point.",
      "gold": "<<Robot>>F delivered",
      "prediction": "<<Robot>>F at_delivery",
      "correct": "no",
      "reasoning": "The temporal/coalition structure matches (<<Robot>>F), but the atomic proposition differs: gold requires eventually delivered, while prediction requires eventually at_delivery (being at the drop-off point). Being at the point is not equivalent to having delivered the package.",
      "decision_method": "llm"
    },
    {
      "input": "The coalition of robots 2 and 3 has a strategy to ensure that eventually either attack or defend holds and not retreat.",
      "gold": "<<Robot2, Robot3>> F ((attack || defend) && !retreat)",
      "prediction": "<<Robot2, Robot3>> F (attack || defend && !retreat)",
      "correct": "no",
      "reasoning": "Gold requires eventually ((attack || defend) && !retreat), i.e., not retreat must hold together with either attack or defend. Prediction parses as (attack || (defend && !retreat)) due to && binding tighter than ||, which allows attack even if retreat holds. Meaning differs.",
      "decision_method": "llm"
    },
    {
      "input": "The machine and the user together can guarantee that the ticket is printed before the system times out.",
      "gold": "<<User,Machine>>(!timeout U ticket_printed)",
      "prediction": "<<Machine,User>>G (ticket_printed && !system_timeout)",
      "correct": "no",
      "reasoning": "Gold <<User,Machine>>(!timeout U ticket_printed) means the coalition can ensure no timeout occurs up to the point when ticket_printed happens (and ticket_printed must eventually occur). Prediction <<Machine,User>>G (ticket_printed && !system_timeout) instead requires ticket_printed to hold at all times and system_timeout to never occur, which is much stronger and not the same 'before timeout' until property.",
      "decision_method": "llm"
    },
    {
      "input": "The mobile robot can guarantee that it will never collide with an obstacle.",
      "gold": "<<Robot>>G !collision",
      "prediction": "<<Robot>>G !obstacle_collision",
      "correct": "yes",
      "reasoning": "Same coalition (Robot) and same temporal requirement (G never). The predicate obstacle_collision is a clear alias of collision with an obstacle, matching the natural-language statement.",
      "decision_method": "llm"
    },
    {
      "input": "Robots number 1 and number 2 have a joint strategy to always avoid position 3.",
      "gold": "<<Robot1, Robot2>> G !pos3",
      "prediction": "<<Robot1, Robot2>> G !in_position_3",
      "correct": "yes",
      "reasoning": "Same coalition {Robot1, Robot2} and same temporal requirement G !p (always avoid). Predicate in_position_3 is a clear alias of pos3.",
      "decision_method": "llm"
    },
    {
      "input": "The smart grid can guarantee that overload will never occur.",
      "gold": "<<Grid>>G !overload",
      "prediction": "<<Grid>>G !overload",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The system and the operator together can guarantee that sooner or later the connection will be restored.",
      "gold": "<<Network,Operator>>F connection_restored",
      "prediction": "<<System,Operator>>F connection_restored",
      "correct": "no",
      "reasoning": "Coalition mismatch: gold attributes the ability to <<Network,Operator>> while the prediction uses <<System,Operator>>. Even with the same F and proposition, changing the agent set changes the meaning in ATL.",
      "decision_method": "llm"
    },
    {
      "input": "The system can guarantee that there will never be false positives when calibration is valid.",
      "gold": "<<System>>G (calibration_ok -> G !false_positive)",
      "prediction": "<<System>>G (!false_positives -> calibration_valid)",
      "correct": "no",
      "reasoning": "Gold says: always, if calibration is valid then from then on always no false positives (calibration_ok -> G !false_positive). Prediction instead states: always, if there are no false positives then calibration is valid (!false_positives -> calibration_valid). This reverses the implication direction and drops the nested G requirement, changing the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The user can guarantee that at the next step there will be no error and that this condition will always remain true.",
      "gold": "<<User>>X G !error",
      "prediction": "<<User>>G (error -> X G !error)",
      "correct": "no",
      "reasoning": "Gold requires the user to ensure that starting from the next state, error is always false (X G !error). Prediction instead states globally that whenever an error occurs, then from the next step onward error will always be false (G (error -> X G !error)). This does not guarantee no error at the next step, and allows errors to occur as long as they are followed by permanent error-freedom, so the temporal structure/meaning differs.",
      "decision_method": "llm"
    },
    {
      "input": "The user can guarantee that at the next step they will perform a valid action or cancel the operation.",
      "gold": "<<User>>X (valid_action || cancel)",
      "prediction": "<<User>>G (X valid_action || X cancelled)",
      "correct": "no",
      "reasoning": "Gold states the user can ensure that in the next step either valid_action or cancel holds. Prediction instead requires globally (at all times) that next step valid_action or next step cancelled holds, strengthening the property with an outer G and also changing the cancel predicate name (cancel vs cancelled). Temporal structure and proposition differ, so meaning is not preserved.",
      "decision_method": "llm"
    },
    {
      "input": "The robot number 3 has a strategy to guarantee that they will reach position 2 in the next step.",
      "gold": "<<Robot3>> X pos2",
      "prediction": "<<Robot3>> X pos2",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The machine can guarantee that the system remains safe until cancellation is requested.",
      "gold": "<<Machine>>(safe U cancel)",
      "prediction": "<<Machine>>(safe U cancellation)",
      "correct": "no",
      "reasoning": "Coalition and until-structure match, but the atomic proposition differs: gold uses `cancel` while prediction uses `cancellation`. Without an explicit alias/equivalence, this changes the stated condition for ending the until.",
      "decision_method": "llm"
    },
    {
      "input": "The drone swarm can guarantee that sooner or later the area will be fully explored.",
      "gold": "<<Swarm>>F area_explored",
      "prediction": "<<Swarm>>F area_explored",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The machine can guarantee that the gate will never open without payment.",
      "gold": "<<Machine>>G (!paid -> !gate_open)",
      "prediction": "<<Machine>>G !payment -> !gate_open",
      "correct": "no",
      "reasoning": "The prediction is parsed as (<<Machine>>G !payment) -> !gate_open due to missing parentheses, not as <<Machine>>G (!payment -> !gate_open). This changes the temporal scope: it no longer states that whenever payment is absent the gate is not open, but instead makes a global claim about payment and then a separate non-temporal constraint on gate_open.",
      "decision_method": "llm"
    },
    {
      "input": "The smart city system can guarantee that if an intersection is congested, then at the next step it will retime the traffic lights.",
      "gold": "<<CitySystem>>G (junction_congested -> X lights_retimed)",
      "prediction": "<<CitySystem>>G (intersection_congested -> X traffic_retimed)",
      "correct": "no",
      "reasoning": "Although the coalition and temporal structure (G with implication to X) match, the atomic propositions differ: gold conditions on junction_congested and ensures lights_retimed, while prediction uses intersection_congested and traffic_retimed. These are not clear aliases, so the meaning may change.",
      "decision_method": "llm"
    },
    {
      "input": "Robots number 1 and number 2 have a strategy to ensure eventually position 1 and always position 3 afterwards.",
      "gold": "<<Robot1, Robot2>> F (pos1 && G pos3)",
      "prediction": "<<Robot1, Robot2>> F (pos1 && X G pos3)",
      "correct": "no",
      "reasoning": "Gold requires that once the eventual state is reached, pos3 holds globally from that same point onward (F(pos1 && G pos3)). Prediction instead requires pos3 to start holding only from the next step after reaching pos1 (F(pos1 && X G pos3)), allowing pos3 to be false at the pos1 state. This changes the meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The smart grid can guarantee that if demand increases, then at the next step it will increase production.",
      "gold": "<<Grid>>G (demand_high -> X production_increased)",
      "prediction": "<<Grid>>G (demand_increased -> X production_increased)",
      "correct": "no",
      "reasoning": "The antecedent predicate differs: gold uses demand_high (demand increases/high demand), while prediction uses demand_increased. This changes the condition under which the grid must act, so the meaning is not guaranteed equivalent.",
      "decision_method": "llm"
    },
    {
      "input": "Aye, aye! and I’ll chase him round Good Hope, and round the Horn, and round the Norway Maelstrom, and round perdition’s flames before I give him up. And this is what ye have shipped for, men! to chase that white whale on both sides of land, and over all sides of earth, till he spouts black blood and rolls fin out.",
      "gold": "<<I>>(chase U enemy_spouts_black_blood && enemy_rolls_fin_out)",
      "prediction": "<<Ship>>G chase_whale",
      "correct": "no",
      "reasoning": "Gold says agent I can ensure chasing continues until the enemy both spouts black blood and rolls fin out (an until condition with a specific termination event). Prediction changes the coalition to Ship, replaces U with G, and drops the required end condition, instead stating the ship can always chase the whale. Meaning is not preserved.",
      "decision_method": "llm"
    },
    {
      "input": "The security system can guarantee that it will keep monitoring until the threat is removed.",
      "gold": "<<SecuritySystem>>(monitoring U threat_removed)",
      "prediction": "<<SecuritySystem>>(monitoring U threat_removed)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "The Romans, in the countries which they annexed, observed closely these measures; they sent colonies and maintained friendly relations with the minor powers, without increasing their strength; they kept down the greater, and did not allow any strong foreign powers to gain authority.",
      "gold": " <<Romans>>G(send-colony && friendly_with_minor_powers && keep_down_the_greater )",
      "prediction": "<<Romans>>(weak_until_strength_low)",
      "correct": "no",
      "reasoning": "Gold states that the Romans can guarantee globally (G) that they send colonies, maintain friendly relations with minor powers, and keep down the greater powers (a conjunction of three ongoing conditions). The prediction instead is an until-style formula with unrelated propositions (weak_until_strength_low) and lacks the global operator and the specified conjunctive measures, so it changes both temporal structure and content.",
      "decision_method": "llm"
    },
    {
      "input": "The system and the farmer together can guarantee that sooner or later the harvest will be saved.",
      "gold": "<<AgriSystem,Farmer>>F harvest_saved",
      "prediction": "<<HarvestSystem,Farmer>>F harvest_saved",
      "correct": "no",
      "reasoning": "Coalition/agent set differs: gold uses <<AgriSystem,Farmer>> but prediction uses <<HarvestSystem,Farmer>>. Agent identity change alters who has the strategic ability, so it is not semantically equivalent.",
      "decision_method": "llm"
    },
    {
      "input": "The medical system can guarantee that it will never administer the wrong medication.",
      "gold": "<<MedicalSystem>>G !wrong_medication",
      "prediction": "<<MedicalSystem>>G !wrong_medication_administered",
      "correct": "yes",
      "reasoning": "Same coalition (MedicalSystem) and same temporal requirement (G never). The predicate 'wrong_medication_administered' is a clear, more explicit rendering of 'administer the wrong medication', matching the intended meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The robotic arm can guarantee that if the target position changes, then at the next step it will start replanning.",
      "gold": "<<Arm>>G (target_changed -> X replanning)",
      "prediction": "<<Arm>>G (target_changed -> X replanning_started)",
      "correct": "yes",
      "reasoning": "Same coalition (Arm) and same temporal structure G( -> X ). The predicate replanning_started is a clear alias of 'start replanning' in the input, matching the intended meaning.",
      "decision_method": "llm"
    },
    {
      "input": "The mobile robot can guarantee that if the map is invalid, then at the next step it will enter exploration mode.",
      "gold": "<<Robot>>G (map_invalid -> X exploration_mode)",
      "prediction": "<<Robot>>G (map_invalid -> X exploration_mode)",
      "correct": "yes",
      "reasoning": "Exact match (normalized).",
      "decision_method": "exact"
    },
    {
      "input": "If the user presses cancel, the machine can guarantee that sooner or later a refund will be issued.",
      "gold": "<<Machine>>G (cancel -> F refund)",
      "prediction": "<<Machine>>G (user_pressed_cancel -> F refunded)",
      "correct": "yes",
      "reasoning": "Same coalition (Machine) and temporal structure: globally, if cancel occurs then eventually a refund occurs. Predicate names are clear paraphrases (cancel ≈ user_pressed_cancel, refund ≈ refunded).",
      "decision_method": "llm"
    },
    {
      "input": "The doctor and the system together can guarantee that sooner or later a correct diagnosis will be made.",
      "gold": "<<Doctor,MedicalSystem>>F diagnosis_done",
      "prediction": "<<Doctor,System>>F diagnosis_correct",
      "correct": "no",
      "reasoning": "The gold formula requires eventual occurrence of diagnosis_done, while the prediction requires eventual diagnosis_correct. These are different propositions (making a diagnosis vs making a correct diagnosis), so the meaning is not preserved, even though the coalition and F operator match.",
      "decision_method": "llm"
    },
    {
      "input": "The rover can guarantee that if it finds an interesting sample, then at the next step it will tag the sample.",
      "gold": "<<Rover>>G (interesting_sample -> X sample_tagged)",
      "prediction": "<<Rover>>G (interesting_sample_found -> X tagged)",
      "correct": "yes",
      "reasoning": "Same coalition (Rover) and same temporal structure G( p -> X q ). The predicates in the prediction are clear paraphrases of the input/gold: 'interesting_sample_found' matches 'interesting_sample' and 'tagged' matches 'sample_tagged'.",
      "decision_method": "llm"
    },
    {
      "input": "The system and the operators together can guarantee that sooner or later the area will be secured.",
      "gold": "<<EmergencySystem,Operators>>F area_secured",
      "prediction": "<<System,Operators>>F area_secured",
      "correct": "no",
      "reasoning": "Coalition mismatch: gold specifies <<EmergencySystem,Operators>> while prediction uses <<System,Operators>>. Agent set must match; otherwise the ability is attributed to a different coalition.",
      "decision_method": "llm"
    },
    {
      "input": "The world’s stable now. People are happy; they get what they want, and they never want what they can’t get. They’re well off; they’re safe; they’re never ill; they’re not afraid of death; they’re blissfully ignorant of passion and old age; they’re plagued with no mothers or fathers; they’ve got no wives, or children, or lovers to feel strongly about; they’re so conditioned that they practically can’t help behaving as they ought to behave.",
      "gold": "<<World>>G stable",
      "prediction": "<<World>>G (happy && wants_met)",
      "correct": "no",
      "reasoning": "Gold states that the World can guarantee stability always (G stable). Prediction instead guarantees always (happy && wants_met), changing the proposition being maintained; it does not express stability.",
      "decision_method": "llm"
    }
  ]
}